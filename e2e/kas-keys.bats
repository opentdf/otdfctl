#!/usr/bin/env bats

load "${BATS_LIB_PATH}/bats-support/load.bash"
load "${BATS_LIB_PATH}/bats-assert/load.bash"

# Helper functions for otdfctl commands
run_otdfctl_key() {
  run sh -c "./otdfctl policy kas-registry key $HOST $WITH_CREDS $*"
}

run_otdfctl_kas_registry_create() {
  run sh -c "./otdfctl policy kas-registry create $HOST $WITH_CREDS $*"
}

run_otdfctl_provider_create() {
  run sh -c "./otdfctl keymanagement provider create $HOST $WITH_CREDS $*"
}

setup_file() {
  echo -n '{"clientId":"opentdf","clientSecret":"secret"}' >creds.json
  export WITH_CREDS='--with-client-creds-file ./creds.json'
  export HOST='--host http://localhost:8080'
  # This command is not a 'kas-registry key' subcommand, so it won't use run_otdfctl_key
  export KAS_URI="https://test-kas-with-keys.com"
  export KAS_NAME="kas-registry-for-keys-test"

  run_otdfctl_kas_registry_create --name $KAS_NAME --uri "$KAS_URI" --public-key-remote 'https://test-kas-with-keys.com' --json
  assert_success
  export KAS_REGISTRY_ID=$(echo "$output" | jq -r '.id')

  run_otdfctl_provider_create --name "test-provider-config-kas-keys" --config '{}' --json
  assert_success
  export PC_ID=$(echo "$output" | jq -r '.id')
  export WRAPPING_KEY="829e937186ff66b82440e60f762605463d758d9c1b7afcbeaf62856c060cd061"
  export PEM_B64=$(echo "pem" | base64)
}

setup() {
  # No setup specific to individual tests needed here currently
  : # No-op
}

teardown_file() {
  ./otdfctl keymanagement provider "$HOST" "$WITH_CREDS" delete --id "$PC_ID"
  # Cannot cleanup KAS registry and keys, since keys cannot be deleted currently.
  unset HOST WITH_CREDS KAS_REGISTRY_ID KAS_NAME KAS_URI PEM_B64 WRAPPING_KEY PC_ID
}

# Helper function to generate a unique key ID
generate_key_id() {
  local length="${1:-8}"

  # Check if /dev/urandom is available
  if [ ! -c /dev/urandom ]; then
    echo "Error: /dev/urandom not found. Cannot generate random string." >&2
    return 1
  fi
  key_id=$(LC_ALL=C tr </dev/urandom -dc 'A-Za-z0-9' 2>/dev/null | head -c "${length}")
  echo "$key_id"
}

generate_kas_name() {
  local length="${1:-6}"

  # Check if /dev/urandom is available
  if [ ! -c /dev/urandom ]; then
    echo "Error: /dev/urandom not found. Cannot generate random string." >&2
    return 1
  fi
  kas_name=$(LC_ALL=C tr </dev/urandom -dc 'A-Za-z0-9' 2>/dev/null | head -c "${length}")
  echo "$kas_name"
}

format_kas_name_as_uri() {
  local input="$1"
  echo "http://${input}.org"
}

@test "kas-keys: create key (local mode, rsa:2048)" {
  KEY_ID=$(generate_key_id)
  # For local mode, a public key is generated by otdfctl.
  # Its exact value cannot be known before running the command without replicating the key generation logic.
  # Thus, we assert its presence and that it\'s a non-empty base64 encoded string. This is the intended assertion.
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${KEY_ID}" --algorithm rsa:2048 --mode local --wrapping-key-id wrapping-key-1 --wrapping-key "${WRAPPING_KEY}" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r .kas_id)" "${KAS_REGISTRY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_id)" "${KEY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_algorithm)" "1" # rsa:2048
  assert_equal "$(echo "$output" | jq -r .key.key_mode)" "1"      # local
  assert_equal "$(echo "$output" | jq -r .key.key_status)" "1"    # active (assuming default)
  # Assert public_key_ctx.pem is present and not empty
  assert_not_equal "$(echo "$output" | jq -r .key.public_key_ctx.pem)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.public_key_ctx.pem)" ""
  # Assert private_key_ctx for local mode
  assert_equal "$(echo "$output" | jq -r .key.private_key_ctx.key_id)" "wrapping-key-1"
  assert_not_equal "$(echo "$output" | jq -r .key.private_key_ctx.wrapped_key)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.private_key_ctx.wrapped_key)" ""
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.created_at)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.updated_at)" "null"
}

@test "kas-keys: create key (local mode, ec:secp256r1)" {
  KEY_ID=$(generate_key_id)
  # For local mode, a public key is generated by otdfctl.
  # Its exact value cannot be known before running the command without replicating the key generation logic.
  # Thus, we assert its presence and that it\'s a non-empty base64 encoded string. This is the intended assertion.
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${KEY_ID}" --algorithm "ec:secp256r1" --mode "local" --wrapping-key-id "wrapping-key-1" --wrapping-key "${WRAPPING_KEY}" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r .kas_id)" "${KAS_REGISTRY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_id)" "${KEY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_algorithm)" "3" # ec:secp256r1
  assert_equal "$(echo "$output" | jq -r .key.key_mode)" "1"      # local
  assert_equal "$(echo "$output" | jq -r .key.key_status)" "1"    # active
  assert_not_equal "$(echo "$output" | jq -r .key.public_key_ctx.pem)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.public_key_ctx.pem)" ""
  assert_equal "$(echo "$output" | jq -r .key.private_key_ctx.key_id)" "wrapping-key-1"
  assert_not_equal "$(echo "$output" | jq -r .key.private_key_ctx.wrapped_key)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.private_key_ctx.wrapped_key)" ""
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.created_at)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.updated_at)" "null"
}

@test "kas-keys: create key (public_key mode)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${KEY_ID}" --algorithm "rsa:2048" --mode "public_key" --public-key-pem "${PEM_B64}" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r .kas_id)" "${KAS_REGISTRY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_id)" "${KEY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_algorithm)" "1" # rsa:2048
  assert_equal "$(echo "$output" | jq -r .key.key_mode)" "4"      # public_key
  assert_equal "$(echo "$output" | jq -r .key.key_status)" "1"    # active
  assert_equal "$(echo "$output" | jq -r .key.public_key_ctx.pem)" "${PEM_B64}"
  # Assert private_key_ctx is null or not present for public_key mode
  assert_equal "$(echo "$output" | jq -r .key.private_key_ctx)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.created_at)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.updated_at)" "null"
}

@test "kas-keys: create key (remote mode)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${KEY_ID}" --algorithm "rsa:2048" --mode "remote" --public-key-pem "${PEM_B64}" --provider-config-id "${PC_ID}" --wrapping-key-id "wrapping-key-remote" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r .kas_id)" "${KAS_REGISTRY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_id)" "${KEY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_algorithm)" "1" # rsa:2048
  assert_equal "$(echo "$output" | jq -r .key.key_mode)" "3"      # remote
  assert_equal "$(echo "$output" | jq -r .key.key_status)" "1"    # active
  assert_equal "$(echo "$output" | jq -r .key.public_key_ctx.pem)" "${PEM_B64}"
  # Assert private_key_ctx is not what it is for local mode, but check its key_id as per previous logic
  # Based on kas-keys.go, remote mode sets privateKeyCtx.key-id = wrapping-key-id
  assert_equal "$(echo "$output" | jq -r .key.private_key_ctx.key_id)" "wrapping-key-remote"
  assert_equal "$(echo "$output" | jq -r .key.private_key_ctx.wrapped_key)" "null" # wrapped_key should not be set for remote
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.created_at)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.updated_at)" "null"
}

@test "kas-keys: create key (provider mode)" {
  KEY_ID=$(generate_key_id)
  WRAPPING_KEY_ID="wrapping-key-for-provider"
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${KEY_ID}" --algorithm "rsa:2048" --mode "provider" --provider-config-id "${PC_ID}" --wrapping-key-id "${WRAPPING_KEY_ID}" --public-key-pem "${PEM_B64}" --private-key-pem "${PEM_B64}" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r .kas_id)" "${KAS_REGISTRY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_id)" "${KEY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_algorithm)" "1" # rsa:2048
  assert_equal "$(echo "$output" | jq -r .key.key_mode)" "2"      # public_key
  assert_equal "$(echo "$output" | jq -r .key.key_status)" "1"    # active
  assert_equal "$(echo "$output" | jq -r .key.public_key_ctx.pem)" "${PEM_B64}"
  assert_equal "$(echo "$output" | jq -r .key.private_key_ctx.wrapped_key)" "${PEM_B64}"
  assert_equal "$(echo "$output" | jq -r .key.private_key_ctx.key_id)" "${WRAPPING_KEY_ID}"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.created_at)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.updated_at)" "null"
}

@test "kas-keys: create key with labels" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${KEY_ID}" --algorithm "rsa:2048" --mode "public_key" --public-key-pem "${PEM_B64}" --label "env=dev" --label "owner=test" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r .kas_id)" "${KAS_REGISTRY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_id)" "${KEY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_algorithm)" "1" # rsa:2048
  assert_equal "$(echo "$output" | jq -r .key.key_mode)" "4"      # public_key
  assert_equal "$(echo "$output" | jq -r .key.key_status)" "1"    # active
  assert_equal "$(echo "$output" | jq -r .key.public_key_ctx.pem)" "${PEM_B64}"
  assert_equal "$(echo "$output" | jq -r .key.private_key_ctx)" "null"
  assert_equal "$(echo "$output" | jq -r '.key.metadata.labels."env"')" "dev"
  assert_equal "$(echo "$output" | jq -r '.key.metadata.labels."owner"')" "test"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.created_at)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.updated_at)" "null"
}

@test "kas-keys: create key (missing key-id)" {
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --algorithm "rsa:2048" --mode "local" --wrapping-key-id "wrapping-key-1" --wrapping-key "${WRAPPING_KEY}"
  assert_failure
  assert_output --partial "Flag '--key-id' is required"
}

@test "kas-keys: create key (missing algorithm)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${KEY_ID}" --mode "local" --wrapping-key-id "wrapping-key-1" --wrapping-key "${WRAPPING_KEY}"
  assert_failure
  assert_output --partial "Flag '--algorithm' is required"
}

@test "kas-keys: create key (missing mode)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${KEY_ID}" --algorithm "rsa:2048" --wrapping-key-id "wrapping-key-1" --wrapping-key "${WRAPPING_KEY}"
  assert_failure
  assert_output --partial "Flag '--mode' is required"
}

@test "kas-keys: create key (local mode, missing wrapping-key-id)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${KEY_ID}" --algorithm "rsa:2048" --mode "local" --wrapping-key "${WRAPPING_KEY}"
  assert_failure
  assert_output --partial "wrapping-key-id is required for mode local"
}

@test "kas-keys: create key (local mode, missing wrapping-key)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${KEY_ID}" --algorithm "rsa:2048" --mode "local" --wrapping-key-id "wrapping-key-1"
  assert_failure
  assert_output --partial "Flag '--wrapping-key' is required"
}

@test "kas-keys: create key (public_key mode, missing pem)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${KEY_ID}" --algorithm "rsa:2048" --mode "public_key"
  assert_failure
  # The error message might vary based on how --public-key-pem is validated if missing.
  # Assuming it's caught by the CLI framework or the command logic.
  assert_output --partial "Flag '--public-key-pem' is required"
}

@test "kas-keys: create key (remote mode, missing pem)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${KEY_ID}" --algorithm "rsa:2048" --mode "remote" --provider-config-id "pc-1" --wrapping-key-id "wk-1"
  assert_failure
  assert_output --partial "Flag '--public-key-pem' is required"
}

@test "kas-keys: create key (remote mode, missing provider-config-id)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${KEY_ID}" --algorithm "rsa:2048" --mode "remote" --public-key-pem "${PEM_B64}" --wrapping-key-id "wk-1"
  assert_failure
  assert_output --partial "Flag '--provider-config-id' is required"
}

@test "kas-keys: create key (remote mode, missing wrapping-key-id)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${KEY_ID}" --algorithm "rsa:2048" --mode "remote" --public-key-pem "${PEM_B64}" --provider-config-id "pc-1"
  assert_failure
  assert_output --partial "wrapping-key-id is required for mode remote"
}

@test "kas-keys: create key (provider mode, missing wrapping-key-id)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${KEY_ID}" --algorithm "rsa:2048" --mode "provider" --provider-config-id "pc-1"
  assert_failure
  assert_output --partial "wrapping-key-id is required for mode provider"
}

@test "kas-keys: create key (provider mode, missing provider-config-id)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${KEY_ID}" --algorithm "rsa:2048" --mode "provider" --wrapping-key-id "wk-1"
  assert_failure
  assert_output --partial "Flag '--provider-config-id' is required"
}

@test "kas-keys: create key (remote mode, pem not base64)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${KEY_ID}" --algorithm "rsa:2048" --mode "remote" --public-key-pem "not-base64-value" --provider-config-id "pc-1" --wrapping-key-id "wk-1"
  assert_failure
  assert_output --partial "pem must be base64 encoded"
}

@test "kas-keys: create key (public_key mode, pem not base64)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${KEY_ID}" --algorithm "rsa:2048" --mode "public_key" --public-key-pem "not-base64-value"
  assert_failure
  assert_output --partial "pem must be base64 encoded"
}

@test "kas-keys: create key (missing kas identifier)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --key-id "${KEY_ID}" --algorithm "rsa:2048" --mode "public_key" --public-key-pem "${PEM_B64}"
  assert_failure
  assert_output --partial "Flag '--kas' is required"
}

@test "kas-keys: create key (using kasName)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_NAME}" --key-id "${KEY_ID}" --algorithm "rsa:2048" --mode "public_key" --public-key-pem "${PEM_B64}" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r .kas_id)" "${KAS_REGISTRY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_id)" "${KEY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_algorithm)" "1" # rsa:2048
  assert_equal "$(echo "$output" | jq -r .key.key_mode)" "4"      # public_key
  assert_equal "$(echo "$output" | jq -r .key.key_status)" "1"    # active
  assert_equal "$(echo "$output" | jq -r .key.public_key_ctx.pem)" "${PEM_B64}"
  assert_equal "$(echo "$output" | jq -r .key.private_key_ctx)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.created_at)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.updated_at)" "null"
}

@test "kas-keys: create key (using kasUri)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_URI}" --key-id "${KEY_ID}" --algorithm "rsa:2048" --mode "public_key" --public-key-pem "${PEM_B64}" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r .kas_id)" "${KAS_REGISTRY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_id)" "${KEY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_algorithm)" "1" # rsa:2048
  assert_equal "$(echo "$output" | jq -r .key.key_mode)" "4"      # public_key
  assert_equal "$(echo "$output" | jq -r .key.key_status)" "1"    # active
  assert_equal "$(echo "$output" | jq -r .key.public_key_ctx.pem)" "${PEM_B64}"
  assert_equal "$(echo "$output" | jq -r .key.private_key_ctx)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.created_at)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.updated_at)" "null"
}

@test "kas-keys: create key (invalid algorithm value)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${KEY_ID}" --algorithm "invalid-algorithm-value" --mode "public_key" --public-key-pem "${PEM_B64}" --json
  assert_failure
  assert_output --partial "invalid algorithm"
}

@test "kas-keys: create key (invalid mode value)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${KEY_ID}" --algorithm "rsa:2048" --mode "invalid-mode-value" --public-key-pem "${PEM_B64}" --json
  assert_failure
  assert_output --partial "invalid mode"
}

@test "kas-keys: create key (duplicate key-id)" {
  KEY_ID_DUPLICATE=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${KEY_ID_DUPLICATE}" --algorithm "rsa:2048" --mode "public_key" --public-key-pem "${PEM_B64}" --json
  assert_success

  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${KEY_ID_DUPLICATE}" --algorithm "rsa:2048" --mode "public_key" --public-key-pem "${PEM_B64}" --json
  assert_failure
  assert_output --partial "Failed to create kas key"
}

@test "kas-keys: create key (invalid kas identifier)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kas "invalid-kas-id" --key-id "${KEY_ID}" --algorithm "rsa:2048" --mode "public_key" --public-key-pem "${PEM_B64}" --json
  assert_failure
  assert_output --partial "Failed to resolve KAS identifier 'invalid-kas-id': not_found: resource not found"
}

@test "kas-keys: create key (invalid hex encoded wrapping-key)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${KEY_ID}" --algorithm "ec:secp256r1" --mode "local" --wrapping-key-id "wrapping-key-1" --wrapping-key "not-hex-encoded" --json
  assert_failure

  assert_output --partial "wrapping-key must be hex encoded"
}

@test "kas-keys: get key by system ID" {
  KEY_ID_GET=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${KEY_ID_GET}" --algorithm "rsa:2048" --mode "public_key" --public-key-pem "${PEM_B64}" --json
  assert_success
  CREATED_KEY_SYSTEM_ID=$(echo "$output" | jq -r .key.id)

  run_otdfctl_key get --key "${CREATED_KEY_SYSTEM_ID}" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r .kas_id)" "${KAS_REGISTRY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.id)" "${CREATED_KEY_SYSTEM_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_id)" "${KEY_ID_GET}"
  assert_equal "$(echo "$output" | jq -r .key.key_algorithm)" "1" # rsa:2048
  assert_equal "$(echo "$output" | jq -r .key.key_mode)" "4"      # public_key
  assert_equal "$(echo "$output" | jq -r .key.key_status)" "1"    # active
  assert_equal "$(echo "$output" | jq -r .key.public_key_ctx.pem)" "${PEM_B64}"
  assert_equal "$(echo "$output" | jq -r .key.private_key_ctx)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.created_at)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.updated_at)" "null"
}

@test "kas-keys: get key by user key-id and kasId" {
  KEY_ID_GET_USER=$(generate_key_id)
  # Using ec:secp256r1 and public_key mode for variety
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${KEY_ID_GET_USER}" --algorithm "ec:secp256r1" --mode "public_key" --public-key-pem "${PEM_B64}" --json
  assert_success
  local created_key_system_id_for_get=$(echo "$output" | jq -r .key.id)

  run_otdfctl_key get --key "${KEY_ID_GET_USER}" --kas "${KAS_REGISTRY_ID}" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r .kas_id)" "${KAS_REGISTRY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.id)" "${created_key_system_id_for_get}"
  assert_equal "$(echo "$output" | jq -r .key.key_id)" "${KEY_ID_GET_USER}"
  assert_equal "$(echo "$output" | jq -r .key.key_algorithm)" "3" # ec:secp256r1
  assert_equal "$(echo "$output" | jq -r .key.key_mode)" "4"      # public_key
  assert_equal "$(echo "$output" | jq -r .key.key_status)" "1"    # active
  assert_equal "$(echo "$output" | jq -r .key.public_key_ctx.pem)" "${PEM_B64}"
  assert_equal "$(echo "$output" | jq -r .key.private_key_ctx)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.created_at)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.updated_at)" "null"
}

@test "kas-keys: get key by user key-id and kasName" {
  KEY_ID_GET_USER_kas=$(generate_key_id)
  run_otdfctl_key create --kas "kas-registry-for-keys-test" --key-id "${KEY_ID_GET_USER_kas}" --algorithm "rsa:2048" --mode "public_key" --public-key-pem "${PEM_B64}" --json
  assert_success
  local created_key_system_id_for_kas_get=$(echo "$output" | jq -r .key.id)

  run_otdfctl_key get --key "${KEY_ID_GET_USER_kas}" --kas "kas-registry-for-keys-test" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r .kas_id)" "${KAS_REGISTRY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.id)" "${created_key_system_id_for_kas_get}"
  assert_equal "$(echo "$output" | jq -r .key.key_id)" "${KEY_ID_GET_USER_kas}"
  assert_equal "$(echo "$output" | jq -r .key.key_algorithm)" "1" # rsa:2048
  assert_equal "$(echo "$output" | jq -r .key.key_mode)" "4"      # public_key
  assert_equal "$(echo "$output" | jq -r .key.key_status)" "1"    # active
  assert_equal "$(echo "$output" | jq -r .key.public_key_ctx.pem)" "${PEM_B64}"
  assert_equal "$(echo "$output" | jq -r .key.private_key_ctx)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.created_at)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.updated_at)" "null"
}

@test "kas-keys: get key by user key-id and kasUri" {
  KEY_ID_GET_USER_kas=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_URI}" --key-id "${KEY_ID_GET_USER_kas}" --algorithm "ec:secp256r1" --mode "public_key" --public-key-pem "${PEM_B64}" --json
  assert_success
  local created_key_system_id_for_kas_get=$(echo "$output" | jq -r .key.id)

  run_otdfctl_key get --key "${KEY_ID_GET_USER_kas}" --kas "${KAS_URI}" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r .kas_id)" "${KAS_REGISTRY_ID}" # Should resolve to the same KAS
  assert_equal "$(echo "$output" | jq -r .key.id)" "${created_key_system_id_for_kas_get}"
  assert_equal "$(echo "$output" | jq -r .key.key_id)" "${KEY_ID_GET_USER_kas}"
  assert_equal "$(echo "$output" | jq -r .key.key_algorithm)" "3" # ec:secp256r1
  assert_equal "$(echo "$output" | jq -r .key.key_mode)" "4"      # public_key
  assert_equal "$(echo "$output" | jq -r .key.key_status)" "1"    # active
  assert_equal "$(echo "$output" | jq -r .key.public_key_ctx.pem)" "${PEM_B64}"
  assert_equal "$(echo "$output" | jq -r .key.private_key_ctx)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.created_at)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.updated_at)" "null"
}

@test "kas-keys: get key (failure: only key-id, missing KAS identifier)" {
  KEY_ID_FAIL_GET=$(generate_key_id)
  # Create a key first so it potentially exists, though the failure should be due to missing KAS context for the get
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${KEY_ID_FAIL_GET}" --algorithm "rsa:2048" --mode "public_key" --public-key-pem "${PEM_B64}" --json
  assert_success

  run_otdfctl_key get --key "${KEY_ID_FAIL_GET}" --json
  assert_failure
  # Error message might vary, but it should indicate an issue with resolving the key or missing parameters
  assert_output --partial "Flag '--kas' is required" # Or a more specific error about missing KAS identifier
}

@test "kas-keys: get key (failure: only kas, missing key-id or system id)" {
  run_otdfctl_key get --kas "${KAS_REGISTRY_ID}" --json
  assert_failure
  assert_output --partial "Flag '--key' is required"
}

@test "kas-keys: get key (not found by system ID)" {
  run_otdfctl_key get --key "39af808f-6cac-403f-90d7-6b88e865860d" --json
  assert_failure
  assert_output --partial "Failed to get kas key" # Error should indicate not found or similar
}

@test "kas-keys: get key (not found by user key-id and kas)" {
  run_otdfctl_key get --key "non-existent-key" --kas "${KAS_REGISTRY_ID}" --json
  assert_failure
  assert_output --partial "Failed to get kas key" # Error should indicate not found or similar
}

@test "kas-keys: update key labels (add)" {
  KEY_ID_UPDATE_LABEL=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${KEY_ID_UPDATE_LABEL}" --algorithm "rsa:2048" --mode "public_key" --public-key-pem "${PEM_B64}" --label "initial=true" --json
  assert_success
  UPDATE_KEY_LABEL_SYSTEM_ID=$(echo "$output" | jq -r .key.id)
  local initial_created_at_seconds=$(echo "$output" | jq -r .key.metadata.created_at.seconds)
  local initial_updated_at_seconds=$(echo "$output" | jq -r .key.metadata.updated_at.seconds)

  run_otdfctl_key update --id "${UPDATE_KEY_LABEL_SYSTEM_ID}" --label "added=true" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r .kas_id)" "${KAS_REGISTRY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.id)" "${UPDATE_KEY_LABEL_SYSTEM_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_id)" "${KEY_ID_UPDATE_LABEL}"
  assert_equal "$(echo "$output" | jq -r .key.key_algorithm)" "1" # rsa:2048
  assert_equal "$(echo "$output" | jq -r .key.key_mode)" "4"      # public_key
  assert_equal "$(echo "$output" | jq -r .key.key_status)" "1"    # active (should not change)
  assert_equal "$(echo "$output" | jq -r .key.public_key_ctx.pem)" "${PEM_B64}"
  assert_equal "$(echo "$output" | jq -r .key.private_key_ctx)" "null"
  assert_equal "$(echo "$output" | jq -r '.key.metadata.labels."initial"')" "true"
  assert_equal "$(echo "$output" | jq -r '.key.metadata.labels."added"')" "true"
  assert_equal "$(echo "$output" | jq -r .key.metadata.created_at.seconds)" "${initial_created_at_seconds}" # created_at should not change

  # Verify with a subsequent get
  run_otdfctl_key get --key "${UPDATE_KEY_LABEL_SYSTEM_ID}" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r '.key.metadata.labels."initial"')" "true"
  assert_equal "$(echo "$output" | jq -r '.key.metadata.labels."added"')" "true"
}

@test "kas-keys: update key labels (replace)" {
  KEY_ID_UPDATE_LABEL_REPLACE=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${KEY_ID_UPDATE_LABEL_REPLACE}" --algorithm "rsa:2048" --mode "public_key" --public-key-pem "${PEM_B64}" --label "initial=true" --json
  assert_success
  UPDATE_KEY_LABEL_REPLACE_SYSTEM_ID=$(echo "$output" | jq -r .key.id)
  local initial_created_at_replace_seconds=$(echo "$output" | jq -r .key.metadata.created_at.seconds)

  run_otdfctl_key update --id "${UPDATE_KEY_LABEL_REPLACE_SYSTEM_ID}" --label "replaced=true" --force-replace-labels --json
  assert_success
  assert_equal "$(echo "$output" | jq -r .kas_id)" "${KAS_REGISTRY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.id)" "${UPDATE_KEY_LABEL_REPLACE_SYSTEM_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_id)" "${KEY_ID_UPDATE_LABEL_REPLACE}"
  assert_equal "$(echo "$output" | jq -r .key.key_algorithm)" "1" # rsa:2048
  assert_equal "$(echo "$output" | jq -r .key.key_mode)" "4"      # public_key
  assert_equal "$(echo "$output" | jq -r .key.key_status)" "1"    # active
  assert_equal "$(echo "$output" | jq -r '.key.metadata.labels."replaced"')" "true"
  assert_equal "$(echo "$output" | jq -r '.key.metadata.labels."initial" // "null"')" "null"
  assert_equal "$(echo "$output" | jq -r .key.metadata.created_at.seconds)" "${initial_created_at_replace_seconds}"

  # Verify with a subsequent get
  run_otdfctl_key get --key "${UPDATE_KEY_LABEL_REPLACE_SYSTEM_ID}" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r '.key.metadata.labels."replaced"')" "true"
  assert_equal "$(echo "$output" | jq -r '.key.metadata.labels."initial" // "null"')" "null"
}

@test "kas-keys: update key (not found)" {
  run_otdfctl_key update --id "39af808f-6cac-403f-90d7-6b88e865860d" --json
  assert_failure
  assert_output --partial "Failed to update kas key"
}

@test "kas-keys: update key (missing id)" {
  run_otdfctl_key update --json
  assert_failure
  assert_output --partial "ERROR    Flag '--id' is required"
}

# LIST Tests
@test "kas-keys: list keys (default limit and offset)" {
  # Create a few keys to ensure there\\'s something to list and to check structure
  KEY_ID_LIST_1=$(generate_key_id)

  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${KEY_ID_LIST_1}" --algorithm "rsa:2048" --mode "public_key" --public-key-pem "${PEM_B64}" --json
  assert_success
  local key1_system_id=$(echo "$output" | jq -r .key.id)

  KEY_ID_LIST_2=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${KEY_ID_LIST_2}" --algorithm "ec:secp256r1" --mode "public_key" --public-key-pem "${PEM_B64}" --json
  assert_success
  local key2_system_id=$(echo "$output" | jq -r .key.id)

  run_otdfctl_key list --json
  assert_success

  # For key1:
  assert_equal "$(echo "$output" | jq -r --arg id "${key1_system_id}" '.[] | select(.key.id == $id) | .key.id')" "${key1_system_id}"
  assert_equal "$(echo "$output" | jq -r --arg id "${key1_system_id}" '.[] | select(.key.id == $id) | .key.key_id')" "${KEY_ID_LIST_1}"
  assert_equal "$(echo "$output" | jq -r --arg id "${key1_system_id}" '.[] | select(.key.id == $id) | .key.key_algorithm')" "1"
  assert_equal "$(echo "$output" | jq -r --arg id "${key1_system_id}" '.[] | select(.key.id == $id) | .key.key_mode')" "4"
  assert_equal "$(echo "$output" | jq -r --arg id "${key1_system_id}" '.[] | select(.key.id == $id) | .key.key_status')" "1"
  assert_equal "$(echo "$output" | jq -r --arg id "${key1_system_id}" '.[] | select(.key.id == $id) | .key.public_key_ctx.pem')" "${PEM_B64}"
  assert_equal "$(echo "$output" | jq -r --arg id "${key1_system_id}" '.[] | select(.key.id == $id) | .key.private_key_ctx')" "null"
  assert_not_equal "$(echo "$output" | jq -r --arg id "${key1_system_id}" '.[] | select(.key.id == $id) | .key.metadata.created_at')" "null"
  assert_not_equal "$(echo "$output" | jq -r --arg id "${key1_system_id}" '.[] | select(.key.id == $id) | .key.metadata.updated_at')" "null"

  # For key2:
  assert_equal "$(echo "$output" | jq -r --arg id "${key2_system_id}" '.[] | select(.key.id == $id) | .key.id')" "${key2_system_id}"
  assert_equal "$(echo "$output" | jq -r --arg id "${key2_system_id}" '.[] | select(.key.id == $id) | .key.key_id')" "${KEY_ID_LIST_2}"
  assert_equal "$(echo "$output" | jq -r --arg id "${key2_system_id}" '.[] | select(.key.id == $id) | .key.key_algorithm')" "3"
  assert_equal "$(echo "$output" | jq -r --arg id "${key2_system_id}" '.[] | select(.key.id == $id) | .key.key_mode')" "4"
  assert_equal "$(echo "$output" | jq -r --arg id "${key2_system_id}" '.[] | select(.key.id == $id) | .key.key_status')" "1"
  assert_equal "$(echo "$output" | jq -r --arg id "${key2_system_id}" '.[] | select(.key.id == $id) | .key.public_key_ctx.pem')" "${PEM_B64}"
  assert_equal "$(echo "$output" | jq -r --arg id "${key2_system_id}" '.[] | select(.key.id == $id) | .key.private_key_ctx')" "null"
  assert_not_equal "$(echo "$output" | jq -r --arg id "${key2_system_id}" '.[] | select(.key.id == $id) | .key.metadata.created_at')" "null"
  assert_not_equal "$(echo "$output" | jq -r --arg id "${key2_system_id}" '.[] | select(.key.id == $id) | .key.metadata.updated_at')" "null"
}

@test "kas-keys: list keys (pagination with limit and offset)" {
  KAS_NAME_LIST=$(generate_kas_name)
  KAS_URI_LIST=$(format_kas_name_as_uri "${KAS_NAME_LIST}")
  KAS_ID_LIST=$(./otdfctl $HOST $WITH_CREDS policy kas-registry create --name "$KAS_NAME_LIST" --uri "$KAS_URI_LIST" --public-key-remote 'https://test-kas-with-keys.com' --json | jq -r '.id')
  assert_not_equal "$KAS_ID_LIST" ""

  # Create a known set of keys for pagination testing
  local key_p1_id=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_ID_LIST}" --key-id "${key_p1_id}" --algorithm "rsa:4096" --mode "public_key" --public-key-pem "${PEM_B64}" --json
  assert_success
  local key_p1_sys_id=$(echo "$output" | jq -r .key.id)

  local key_p2_id=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_ID_LIST}" --key-id "${key_p2_id}" --algorithm "ec:secp256r1" --mode "public_key" --public-key-pem "${PEM_B64}" --json
  assert_success
  local key_p2_sys_id=$(echo "$output" | jq -r .key.id)

  local key_p3_id=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_ID_LIST}" --key-id "${key_p3_id}" --algorithm "rsa:2048" --mode "public_key" --public-key-pem "${PEM_B64}" --json
  assert_success
  local key_p3_sys_id=$(echo "$output" | jq -r .key.id)

  # Test: limit 1, offset 0 - should get the first key (order dependent on server, so we check for one of them)
  run_otdfctl_key list --kas "${KAS_ID_LIST}" --limit 1 --offset 0 --json
  assert_success
  assert_equal "$(echo "$output" | jq '. | length')" "1"
  local found_id_limit1_offset0=$(echo "$output" | jq -r '.[0].key.id')

  # Test: limit 1, offset 1 - should get the second key
  run_otdfctl_key list --kas "${KAS_ID_LIST}" --limit 1 --offset 1 --json
  assert_success
  assert_equal "$(echo "$output" | jq '. | length')" "1"
  local found_id_limit1_offset1=$(echo "$output" | jq -r '.[0].key.id')
  assert_not_equal "${found_id_limit1_offset1}" "${found_id_limit1_offset0}"

  run_otdfctl_key list --kas "${KAS_ID_LIST}" --limit 3 --offset 0 --json # Fetch up to 3
  assert_success
  local count_limit3_offset0=$(echo "$output" | jq '. | length')
  assert_equal "${count_limit3_offset0}" 3
  assert_equal "$(echo "$output" | jq -r --arg id "${key_p1_sys_id}" '.[] | select(.key.id == $id) | .key.id')" "${key_p1_sys_id}"
  assert_equal "$(echo "$output" | jq -r --arg id "${key_p2_sys_id}" '.[] | select(.key.id == $id) | .key.id')" "${key_p2_sys_id}"
  assert_equal "$(echo "$output" | jq -r --arg id "${key_p3_sys_id}" '.[] | select(.key.id == $id) | .key.id')" "${key_p3_sys_id}"

  # Test: limit 1, offset (large number, e.g., 100) - should get 0 keys
  run_otdfctl_key list --kas "${KAS_ID_LIST}" --limit 1 --offset 100 --json
  assert_success
  assert_equal "$(echo "$output" | jq '. | length')" "0"
}

@test "kas-keys: list keys (filter by algorithm rsa:2048)" {
  KAS_NAME_LIST=$(generate_kas_name)
  KAS_URI_LIST=$(format_kas_name_as_uri "${KAS_NAME_LIST}")
  KAS_ID_LIST=$(./otdfctl $HOST $WITH_CREDS policy kas-registry create --name "$KAS_NAME_LIST" --uri "$KAS_URI_LIST" --public-key-remote 'https://test-kas-with-keys.com' --json | jq -r '.id')
  assert_not_equal "$KAS_ID_LIST" ""

  # Ensure at least one rsa:2048 key exists for this KAS
  KEY_ID_LIST_RSA=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_ID_LIST}" --key-id "${KEY_ID_LIST_RSA}" --algorithm "rsa:2048" --mode "public_key" --public-key-pem "${PEM_B64}" --json
  assert_success
  local rsa_key_sys_id=$(echo "$output" | jq -r .key.id)

  # Ensure at least one non-rsa:2048 key exists for this KAS to test filtering
  KEY_ID_LIST_EC=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_ID_LIST}" --key-id "${KEY_ID_LIST_EC}" --algorithm "ec:secp256r1" --mode "public_key" --public-key-pem "${PEM_B64}" --json
  assert_success
  local ec_key_sys_id=$(echo "$output" | jq -r .key.id)

  run_otdfctl_key list --kas "${KAS_ID_LIST}" --algorithm "rsa:2048" --json
  assert_success
  # Every key in the list should be rsa:2048
  # And our specific RSA key should be present
  assert_equal "$(echo "$output" | jq -r --arg id "${rsa_key_sys_id}" '.[] | select(.key.id == $id) | .key.id')" "${rsa_key_sys_id}"
  assert_equal "$(echo "$output" | jq -r --arg id "${rsa_key_sys_id}" '.[] | select(.key.id == $id) | .key.key_id')" "${KEY_ID_LIST_RSA}"
  assert_equal "$(echo "$output" | jq -r --arg id "${rsa_key_sys_id}" '.[] | select(.key.id == $id) | .key.key_algorithm')" "1"
  assert_equal "$(echo "$output" | jq -r --arg id "${rsa_key_sys_id}" '.[] | select(.key.id == $id) | .key.key_mode')" "4"
  assert_equal "$(echo "$output" | jq -r --arg id "${rsa_key_sys_id}" '.[] | select(.key.id == $id) | .key.key_status')" "1"
  assert_equal "$(echo "$output" | jq -r --arg id "${rsa_key_sys_id}" '.[] | select(.key.id == $id) | .key.public_key_ctx.pem')" "${PEM_B64}"
  assert_equal "$(echo "$output" | jq -r --arg id "${rsa_key_sys_id}" '.[] | select(.key.id == $id) | .key.private_key_ctx')" "null"
  assert_not_equal "$(echo "$output" | jq -r --arg id "${rsa_key_sys_id}" '.[] | select(.key.id == $id) | .key.metadata.created_at')" "null"
  assert_not_equal "$(echo "$output" | jq -r --arg id "${rsa_key_sys_id}" '.[] | select(.key.id == $id) | .key.metadata.updated_at')" "null"

  # Check that all listed keys have key_algorithm 1 (algorithmORITHM_RSA_2048)
  local count_non_rsa=$(echo "$output" | jq '[.[] | select(.key.key_algorithm != 1)] | length')
  assert_equal "$count_non_rsa" "0"
}

@test "kas-keys: list keys (filter by kas)" {
  KAS_NAME_LIST=$(generate_kas_name)
  KAS_URI_LIST=$(format_kas_name_as_uri "${KAS_NAME_LIST}")
  KAS_ID_LIST=$(./otdfctl $HOST $WITH_CREDS policy kas-registry create --name "$KAS_NAME_LIST" --uri "$KAS_URI_LIST" --public-key-remote 'https://test-kas-with-keys.com' --json | jq -r '.id')
  assert_not_equal "$KAS_ID_LIST" ""

  KEY_ID_LIST_KAS_FILTER=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_ID_LIST}" --key-id "${KEY_ID_LIST_KAS_FILTER}" --algorithm "rsa:2048" --mode "public_key" --public-key-pem "${PEM_B64}" --json
  assert_success
  local kas_filter_key_sys_id=$(echo "$output" | jq -r .key.id)

  # List keys for the new KAS
  run_otdfctl_key list --kas "${KAS_ID_LIST}" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r '.[0].kas_id')" "${KAS_ID_LIST}"
  assert_equal "$(echo "$output" | jq -r '.[0].key.id')" "${kas_filter_key_sys_id}"
  assert_equal "$(echo "$output" | jq -r '.[0].key.key_id')" "${KEY_ID_LIST_KAS_FILTER}"
  assert_equal "$(echo "$output" | jq -r '.[0].key.key_algorithm')" "1"
  assert_equal "$(echo "$output" | jq -r '.[0].key.key_mode')" "4"
  assert_equal "$(echo "$output" | jq -r '.[0].key.key_status')" "1"
  assert_equal "$(echo "$output" | jq -r '.[0].key.public_key_ctx.pem')" "${PEM_B64}"
  assert_equal "$(echo "$output" | jq -r '.[0].key.private_key_ctx')" "null"
  assert_not_equal "$(echo "$output" | jq -r '.[0].key.metadata.created_at')" "null"
  assert_not_equal "$(echo "$output" | jq -r '.[0].key.metadata.updated_at')" "null"
  assert_equal "$(echo "$output" | jq '. | length')" "1"

  # List keys for the default KAS_REGISTRY_ID and ensure the new key is not present
  run_otdfctl_key list --kas "${KAS_REGISTRY_ID}" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r --arg id "${kas_filter_key_sys_id}" '[.[] | select(.key.id == $id)] | length')" "0"
}

@test "kas-keys: list keys (filter by kasName)" {
  KAS_NAME_LIST=$(generate_kas_name)
  echo "DEBUG: KAS_NAME_LIST: ${KAS_NAME_LIST}" >&2
  KAS_URI_LIST=$(format_kas_name_as_uri "${KAS_NAME_LIST}")
  KAS_ID_LIST=$(./otdfctl $HOST $WITH_CREDS policy kas-registry create --name "$KAS_NAME_LIST" --uri "$KAS_URI_LIST" --public-key-remote 'https://test-kas-with-keys.com' --json | jq -r '.id')
  assert_not_equal "$KAS_ID_LIST" ""

  KEY_ID_LIST_KAS_NAME_FILTER=$(generate_key_id)
  local lower_kas_name=$(echo "${KAS_NAME_LIST}" | tr '[:upper:]' '[:lower:]')
  run_otdfctl_key create --kas "${lower_kas_name}" --key-id "${KEY_ID_LIST_KAS_NAME_FILTER}" --algorithm "rsa:2048" --mode "public_key" --public-key-pem "${PEM_B64}" --json
  assert_success
  local kas_name_filter_key_sys_id=$(echo "$output" | jq -r .key.id)

  run_otdfctl_key list --kas "${lower_kas_name}" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r '.[0].kas_id')" "${KAS_ID_LIST}"
  assert_equal "$(echo "$output" | jq -r '.[0].key.id')" "${kas_name_filter_key_sys_id}"
  assert_equal "$(echo "$output" | jq -r '.[0].key.key_id')" "${KEY_ID_LIST_KAS_NAME_FILTER}"
  assert_equal "$(echo "$output" | jq -r '.[0].key.key_algorithm')" "1"
  assert_equal "$(echo "$output" | jq -r '.[0].key.key_mode')" "4"
  assert_equal "$(echo "$output" | jq -r '.[0].key.key_status')" "1"
  assert_equal "$(echo "$output" | jq -r '.[0].key.public_key_ctx.pem')" "${PEM_B64}"
  assert_equal "$(echo "$output" | jq -r '.[0].key.private_key_ctx')" "null"
  assert_not_equal "$(echo "$output" | jq -r '.[0].key.metadata.created_at')" "null"
  assert_not_equal "$(echo "$output" | jq -r '.[0].key.metadata.updated_at')" "null"
}

@test "kas-keys: list keys (filter by kasUri)" {
  # This command is not a 'kas-registry key' subcommand, so it won't use run_otdfctl_key
  KAS_NAME_LIST=$(generate_kas_name)
  KAS_URI_LIST=$(format_kas_name_as_uri "${KAS_NAME_LIST}")
  KAS_ID_LIST=$(./otdfctl $HOST $WITH_CREDS policy kas-registry create --name "$KAS_NAME_LIST" --uri "$KAS_URI_LIST" --public-key-remote 'https://test-kas-with-keys.com' --json | jq -r '.id')
  assert_not_equal "$KAS_ID_LIST" ""

  KEY_ID_LIST_KAS_URI_FILTER=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_URI_LIST}" --key-id "${KEY_ID_LIST_KAS_URI_FILTER}" --algorithm "rsa:2048" --mode "public_key" --public-key-pem "${PEM_B64}" --json
  assert_success
  local kas_uri_filter_key_sys_id=$(echo "$output" | jq -r .key.id)

  run_otdfctl_key list --kas "${KAS_URI_LIST}" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r '.[0].kas_id')" "${KAS_ID_LIST}"
  assert_equal "$(echo "$output" | jq -r '.[0].key.id')" "${kas_uri_filter_key_sys_id}"
  assert_equal "$(echo "$output" | jq -r '.[0].key.key_id')" "${KEY_ID_LIST_KAS_URI_FILTER}"
  assert_equal "$(echo "$output" | jq -r '.[0].key.key_algorithm')" "1"
  assert_equal "$(echo "$output" | jq -r '.[0].key.key_mode')" "4"
  assert_equal "$(echo "$output" | jq -r '.[0].key.key_status')" "1"
  assert_equal "$(echo "$output" | jq -r '.[0].key.public_key_ctx.pem')" "${PEM_B64}"
}

@test "kas-keys: list keys (invalid algorithm)" {
  run_otdfctl_key list --algorithm "invalid-algorithm" --json
  assert_failure
  assert_output --partial "Invalid algorithm"
}

@test "kas-keys: rotate key" {
  # Create a key first
  OLD_KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${OLD_KEY_ID}" --algorithm "rsa:2048" --mode "local" --wrapping-key-id "wrapping-key-1" --wrapping-key "${WRAPPING_KEY}" --json
  assert_success
  OLD_KEY_SYSTEM_ID=$(echo "$output" | jq -r .key.id)

  # Rotate the key
  NEW_KEY_ID=$(generate_key_id)
  run_otdfctl_key rotate --key "${OLD_KEY_SYSTEM_ID}" --key-id "${NEW_KEY_ID}" --algorithm "rsa:2048" --mode "local" --wrapping-key-id "wrapping-key-2" --wrapping-key "${WRAPPING_KEY}" --json
  assert_success

  # Verify the new key in kas_key section
  NEW_KEY_SYSTEM_ID=$(echo "$output" | jq -r .kas_key.key.id)
  assert_not_equal "${OLD_KEY_SYSTEM_ID}" "${NEW_KEY_SYSTEM_ID}"
  assert_equal "$(echo "$output" | jq -r .kas_key.key.key_id)" "${NEW_KEY_ID}"
  assert_equal "$(echo "$output" | jq -r .kas_key.key.key_algorithm)" "1" # rsa:2048
  assert_equal "$(echo "$output" | jq -r .kas_key.key.key_mode)" "1"      # local
  assert_equal "$(echo "$output" | jq -r .kas_key.key.key_status)" "1"    # active (new key should be active)
  assert_not_equal "$(echo "$output" | jq -r .kas_key.key.public_key_ctx.pem)" "null"
  assert_not_equal "$(echo "$output" | jq -r .kas_key.key.public_key_ctx.pem)" ""
  assert_equal "$(echo "$output" | jq -r .kas_key.key.private_key_ctx.key_id)" "wrapping-key-2"
  assert_not_equal "$(echo "$output" | jq -r .kas_key.key.private_key_ctx.wrapped_key)" "null"
  assert_not_equal "$(echo "$output" | jq -r .kas_key.key.private_key_ctx.wrapped_key)" ""
  assert_not_equal "$(echo "$output" | jq -r .kas_key.key.metadata.created_at)" "null"
  assert_not_equal "$(echo "$output" | jq -r .kas_key.key.metadata.updated_at)" "null"

  # Verify the old rotated key in rotated_resources section
  assert_equal "$(echo "$output" | jq -r .rotated_resources.rotated_out_key.key.id)" "${OLD_KEY_SYSTEM_ID}"
  assert_equal "$(echo "$output" | jq -r .rotated_resources.rotated_out_key.key.key_id)" "${OLD_KEY_ID}"
  assert_equal "$(echo "$output" | jq -r .rotated_resources.rotated_out_key.key.key_status)" "2" # rotated (old key should be marked as rotated)
}

@test "kas-keys: rotate key (missing key)" {
  run_otdfctl_key rotate --key-id "new-key-id" --algorithm "rsa:2048" --mode "public_key" --public-key-pem "${PEM_B64}"
  assert_failure
  assert_output --partial "Flag '--key' is required"
}

@test "kas-keys: rotate key (missing key-id)" {
  run_otdfctl_key rotate --key "old-key-id" --algorithm "rsa:2048" --mode "public_key" --public-key-pem "${PEM_B64}"
  assert_failure
  assert_output --partial "Flag '--key-id' is required"
}

@test "kas-keys: rotate key (missing algorithm)" {
  run_otdfctl_key rotate --key "old-key-id" --key-id "new-key-id" --mode "public_key" --public-key-pem "${PEM_B64}"
  assert_failure
  assert_output --partial "Flag '--algorithm' is required"
}

@test "kas-keys: rotate key (missing mode)" {
  run_otdfctl_key rotate --key "old-key-id" --key-id "new-key-id" --algorithm "rsa:2048" --public-key-pem "${PEM_B64}"
  assert_failure
  assert_output --partial "Flag '--mode' is required"
}

@test "kas-keys: rotate key (local mode, missing wrapping-key-id)" {
  run_otdfctl_key rotate --key "old-key-id" --key-id "new-key-id" --algorithm "rsa:2048" --mode "local" --wrapping-key "${WRAPPING_KEY}"
  assert_failure
  assert_output --partial "wrapping-key-id is required for mode local"
}

@test "kas-keys: rotate key (local mode, missing wrapping-key)" {
  run_otdfctl_key rotate --key "old-key-id" --key-id "new-key-id" --algorithm "rsa:2048" --mode "local" --wrapping-key-id "wrapping-key-1"
  assert_failure
  assert_output --partial "Flag '--wrapping-key' is required"
}

@test "kas-keys: rotate key (public_key mode, missing public-key-pem)" {
  run_otdfctl_key rotate --key "old-key-id" --key-id "new-key-id" --algorithm "rsa:2048" --mode "public_key"
  assert_failure
  assert_output --partial "Flag '--public-key-pem' is required"
}

@test "kas-keys: rotate key (remote mode, missing provider-config-id)" {
  run_otdfctl_key rotate --key "old-key-id" --key-id "new-key-id" --algorithm "rsa:2048" --mode "remote" --public-key-pem "${PEM_B64}" --wrapping-key-id "wk-1"
  assert_failure
  assert_output --partial "Flag '--provider-config-id' is required"
}

@test "kas-keys: rotate key (invalid algorithm)" {
  # Create a key first that we can try to rotate
  OLD_KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${OLD_KEY_ID}" --algorithm "rsa:2048" --mode "public_key" --public-key-pem "${PEM_B64}" --json
  assert_success

  # Try to rotate with invalid algorithm
  NEW_KEY_ID=$(generate_key_id)
  run_otdfctl_key rotate --key "${OLD_KEY_ID}" --key-id "${NEW_KEY_ID}" --algorithm "invalid-algorithm" --mode "public_key" --public-key-pem "${PEM_B64}"
  assert_failure
  assert_output --partial "invalid algorithm"
}

@test "kas-keys: rotate key (invalid mode)" {
  # Create a key first that we can try to rotate
  OLD_KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${OLD_KEY_ID}" --algorithm "rsa:2048" --mode "public_key" --public-key-pem "${PEM_B64}" --json
  assert_success

  # Try to rotate with invalid mode
  NEW_KEY_ID=$(generate_key_id)
  run_otdfctl_key rotate --key "${OLD_KEY_ID}" --key-id "${NEW_KEY_ID}" --algorithm "rsa:2048" --mode "invalid-mode" --public-key-pem "${PEM_B64}"
  assert_failure
  assert_output --partial "invalid mode"
}

@test "kas-keys: rotate key (invalid hex encoded wrapping-key)" {
  # Create a key first that we can try to rotate
  OLD_KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kas "${KAS_REGISTRY_ID}" --key-id "${OLD_KEY_ID}" --algorithm "rsa:2048" --mode "public_key" --public-key-pem "${PEM_B64}" --json
  assert_success

  # Try to rotate with invalid wrapping-key
  NEW_KEY_ID=$(generate_key_id)
  run_otdfctl_key rotate --key "${OLD_KEY_ID}" --key-id "${NEW_KEY_ID}" --algorithm "rsa:2048" --mode "local" --public-key-pem "${PEM_B64}" --wrapping-key "not-hex-encoded"
  assert_failure
  assert_output --partial "wrapping-key must be hex encoded"
}
