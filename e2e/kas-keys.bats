#!/usr/bin/env bats

setup_file() {
  echo -n '{"clientId":"opentdf","clientSecret":"secret"}' > creds.json
  export WITH_CREDS='--with-client-creds-file ./creds.json'
  export HOST='--host http://localhost:8080'
  # This command is not a 'kas-registry key' subcommand, so it won't use run_otdfctl_key
  export KAS_URI="https://test-kas-with-keys.com"
  export KAS_NAME="kas-registry-for-keys-test"
  export KAS_REGISTRY_ID=$(./otdfctl $HOST $WITH_CREDS policy kas-registry create --name $KAS_NAME --uri "$KAS_URI" --public-key-remote 'https://test-kas-with-keys.com' --json | jq -r '.id')
  export PC_ID=$(./otdfctl $HOST $WITH_CREDS keymanagement provider create --name "test-provider-config-kas-keys" --config '{}' --json | jq -r '.id')
  export WRAPPING_KEY="gp6TcYb/ZrgkQOYPdiYFRj11jZwbevy+r2KFbAYM0GE="
  export PEM_B64=$(echo "pem" | base64)
}

setup() {
    load "${BATS_LIB_PATH}/bats-support/load.bash"
    load "${BATS_LIB_PATH}/bats-assert/load.bash"

    # invoke binary with credentials
    run_otdfctl_key () {
      run sh -c "./otdfctl policy kas-registry key $HOST $WITH_CREDS $*"
    }
}


teardown_file() {
  ./otdctl keymanagement provider "$HOST" "$WITH_CREDS" delete --id "$PC_ID"
  # Cannot cleanup KAS registry and keys, since keys cannot be deleted currently.
  unset HOST WITH_CREDS KAS_REGISTRY_ID KAS_NAME KAS_URI PEM_B64 WRAPPING_KEY PC_ID
}

# Helper function to generate a unique key ID
generate_key_id() {
  local length="${1:-8}"

  # Check if /dev/urandom is available
  if [ ! -c /dev/urandom ]; then
    echo "Error: /dev/urandom not found. Cannot generate random string." >&2
    return 1
  fi
  key_id=$(LC_ALL=C < /dev/urandom tr -dc 'A-Za-z0-9' 2>/dev/null  | head -c "${length}")
  echo "$key_id"
}

generate_kas_name() {
  local length="${1:-6}"

  # Check if /dev/urandom is available
  if [ ! -c /dev/urandom ]; then
    echo "Error: /dev/urandom not found. Cannot generate random string." >&2
    return 1
  fi
  kas_name=$(LC_ALL=C < /dev/urandom tr -dc 'A-Za-z0-9' 2>/dev/null | head -c "${length}")
  echo "$kas_name"
}

format_kas_name_as_uri() {
  local input="$1"
  echo "http://${input}.org"
}

@test "kas-keys: create key (local mode, rsa:2048)" {
  KEY_ID=$(generate_key_id)
  # For local mode, a public key is generated by otdfctl.
  # Its exact value cannot be known before running the command without replicating the key generation logic.
  # Thus, we assert its presence and that it\'s a non-empty base64 encoded string. This is the intended assertion.
  run_otdfctl_key create --kasId "${KAS_REGISTRY_ID}" --keyId "${KEY_ID}" --alg rsa:2048 --mode local --wrappingKeyId wrapping-key-1 --wrappingKey "${WRAPPING_KEY}" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r .kas_id)" "${KAS_REGISTRY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_id)" "${KEY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_algorithm)" "1" # rsa:2048
  assert_equal "$(echo "$output" | jq -r .key.key_mode)" "1"    # local
  assert_equal "$(echo "$output" | jq -r .key.key_status)" "1"   # active (assuming default)
  # Assert public_key_ctx.pem is present and not empty
  assert_not_equal "$(echo "$output" | jq -r .key.public_key_ctx.pem)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.public_key_ctx.pem)" ""
  # Assert private_key_ctx for local mode
  assert_equal "$(echo "$output" | jq -r .key.private_key_ctx.key_id)" "wrapping-key-1"
  assert_not_equal "$(echo "$output" | jq -r .key.private_key_ctx.wrapped_key)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.private_key_ctx.wrapped_key)" ""
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.created_at)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.updated_at)" "null"
}

@test "kas-keys: create key (local mode, ec:secp256r1)" {
  KEY_ID=$(generate_key_id)
  # For local mode, a public key is generated by otdfctl.
  # Its exact value cannot be known before running the command without replicating the key generation logic.
  # Thus, we assert its presence and that it\'s a non-empty base64 encoded string. This is the intended assertion.
  run_otdfctl_key create --kasId "${KAS_REGISTRY_ID}" --keyId "${KEY_ID}" --alg "ec:secp256r1" --mode "local" --wrappingKeyId "wrapping-key-1" --wrappingKey "${WRAPPING_KEY}" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r .kas_id)" "${KAS_REGISTRY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_id)" "${KEY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_algorithm)" "3" # ec:secp256r1
  assert_equal "$(echo "$output" | jq -r .key.key_mode)" "1"    # local
  assert_equal "$(echo "$output" | jq -r .key.key_status)" "1"   # active
  assert_not_equal "$(echo "$output" | jq -r .key.public_key_ctx.pem)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.public_key_ctx.pem)" ""
  assert_equal "$(echo "$output" | jq -r .key.private_key_ctx.key_id)" "wrapping-key-1"
  assert_not_equal "$(echo "$output" | jq -r .key.private_key_ctx.wrapped_key)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.private_key_ctx.wrapped_key)" ""
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.created_at)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.updated_at)" "null"
}

@test "kas-keys: create key (public_key mode)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kasId "${KAS_REGISTRY_ID}" --keyId "${KEY_ID}" --alg "rsa:2048" --mode "public_key" --pubPem "${PEM_B64}" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r .kas_id)" "${KAS_REGISTRY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_id)" "${KEY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_algorithm)" "1" # rsa:2048
  assert_equal "$(echo "$output" | jq -r .key.key_mode)" "4"    # public_key
  assert_equal "$(echo "$output" | jq -r .key.key_status)" "1"   # active
  assert_equal "$(echo "$output" | jq -r .key.public_key_ctx.pem)" "${PEM_B64}"
  # Assert private_key_ctx is null or not present for public_key mode
  assert_equal "$(echo "$output" | jq -r .key.private_key_ctx)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.created_at)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.updated_at)" "null"
}

@test "kas-keys: create key (remote mode)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kasId "${KAS_REGISTRY_ID}" --keyId "${KEY_ID}" --alg "rsa:2048" --mode "remote" --pubPem "${PEM_B64}" --providerConfigId "${PC_ID}" --wrappingKeyId "wrapping-key-remote" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r .kas_id)" "${KAS_REGISTRY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_id)" "${KEY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_algorithm)" "1" # rsa:2048
  assert_equal "$(echo "$output" | jq -r .key.key_mode)" "3"    # remote
  assert_equal "$(echo "$output" | jq -r .key.key_status)" "1"   # active
  assert_equal "$(echo "$output" | jq -r .key.public_key_ctx.pem)" "${PEM_B64}"
  # Assert private_key_ctx is not what it is for local mode, but check its key_id as per previous logic
  # Based on kas-keys.go, remote mode sets privateKeyCtx.KeyId = wrappingKeyId
  assert_equal "$(echo "$output" | jq -r .key.private_key_ctx.key_id)" "wrapping-key-remote"
  assert_equal "$(echo "$output" | jq -r .key.private_key_ctx.wrapped_key)" "null" # wrapped_key should not be set for remote
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.created_at)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.updated_at)" "null"
}

@test "kas-keys: create key (provider mode)" {
  KEY_ID=$(generate_key_id)
  WRAPPING_KEY_ID="wrapping-key-for-provider"
  run_otdfctl_key create --kasId "${KAS_REGISTRY_ID}" --keyId "${KEY_ID}" --alg "rsa:2048" --mode "provider" --providerConfigId "${PC_ID}" --wrappingKeyId "${WRAPPING_KEY_ID}" --pubPem "${PEM_B64}" --privatePem "${PEM_B64}" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r .kas_id)" "${KAS_REGISTRY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_id)" "${KEY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_algorithm)" "1" # rsa:2048
  assert_equal "$(echo "$output" | jq -r .key.key_mode)" "2"    # public_key
  assert_equal "$(echo "$output" | jq -r .key.key_status)" "1"   # active
  assert_equal "$(echo "$output" | jq -r .key.public_key_ctx.pem)" "${PEM_B64}"
  assert_equal "$(echo "$output" | jq -r .key.private_key_ctx.wrapped_key)" "${PEM_B64}"
  assert_equal "$(echo "$output" | jq -r .key.private_key_ctx.key_id)" "${WRAPPING_KEY_ID}"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.created_at)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.updated_at)" "null"
}

@test "kas-keys: create key with labels" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kasId "${KAS_REGISTRY_ID}" --keyId "${KEY_ID}" --alg "rsa:2048" --mode "public_key" --pubPem "${PEM_B64}" --label "env=dev" --label "owner=test" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r .kas_id)" "${KAS_REGISTRY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_id)" "${KEY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_algorithm)" "1" # rsa:2048
  assert_equal "$(echo "$output" | jq -r .key.key_mode)" "4"    # public_key
  assert_equal "$(echo "$output" | jq -r .key.key_status)" "1"   # active
  assert_equal "$(echo "$output" | jq -r .key.public_key_ctx.pem)" "${PEM_B64}"
  assert_equal "$(echo "$output" | jq -r .key.private_key_ctx)" "null"
  assert_equal "$(echo "$output" | jq -r '.key.metadata.labels."env"')" "dev"
  assert_equal "$(echo "$output" | jq -r '.key.metadata.labels."owner"')" "test"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.created_at)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.updated_at)" "null"
}

@test "kas-keys: create key (missing keyId)" {
  run_otdfctl_key create --kasId "${KAS_REGISTRY_ID}" --alg "rsa:2048" --mode "local" --wrappingKeyId "wrapping-key-1" --wrappingKey "${WRAPPING_KEY}"
  assert_failure
  assert_output --partial "Flag '--keyId' is required"
}

@test "kas-keys: create key (missing alg)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kasId "${KAS_REGISTRY_ID}" --keyId "${KEY_ID}" --mode "local" --wrappingKeyId "wrapping-key-1" --wrappingKey "${WRAPPING_KEY}"
  assert_failure
  assert_output --partial "Flag '--alg' is required"
}

@test "kas-keys: create key (missing mode)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kasId "${KAS_REGISTRY_ID}" --keyId "${KEY_ID}" --alg "rsa:2048" --wrappingKeyId "wrapping-key-1" --wrappingKey "${WRAPPING_KEY}"
  assert_failure
  assert_output --partial "Flag '--mode' is required"
}

@test "kas-keys: create key (local mode, missing wrappingKeyId)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kasId "${KAS_REGISTRY_ID}" --keyId "${KEY_ID}" --alg "rsa:2048" --mode "local" --wrappingKey "${WRAPPING_KEY}"
  assert_failure
  assert_output --partial "wrappingKeyId is required for mode local"
}

@test "kas-keys: create key (local mode, missing wrappingKey)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kasId "${KAS_REGISTRY_ID}" --keyId "${KEY_ID}" --alg "rsa:2048" --mode "local" --wrappingKeyId "wrapping-key-1"
  assert_failure
  assert_output --partial "Flag '--wrappingKey' is required"
}

@test "kas-keys: create key (public_key mode, missing pem)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kasId "${KAS_REGISTRY_ID}" --keyId "${KEY_ID}" --alg "rsa:2048" --mode "public_key"
  assert_failure
  # The error message might vary based on how --pubPem is validated if missing.
  # Assuming it's caught by the CLI framework or the command logic.
  assert_output --partial "Flag '--pubPem' is required"
}

@test "kas-keys: create key (remote mode, missing pem)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kasId "${KAS_REGISTRY_ID}" --keyId "${KEY_ID}" --alg "rsa:2048" --mode "remote" --providerConfigId "pc-1" --wrappingKeyId "wk-1"
  assert_failure
  assert_output --partial "Flag '--pubPem' is required"
}

@test "kas-keys: create key (remote mode, missing providerConfigId)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kasId "${KAS_REGISTRY_ID}" --keyId "${KEY_ID}" --alg "rsa:2048" --mode "remote" --pubPem "${PEM_B64}" --wrappingKeyId "wk-1"
  assert_failure
  assert_output --partial "providerConfigId is required for mode remote"
}

@test "kas-keys: create key (remote mode, missing wrappingKeyId)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kasId "${KAS_REGISTRY_ID}" --keyId "${KEY_ID}" --alg "rsa:2048" --mode "remote" --pubPem "${PEM_B64}" --providerConfigId "pc-1"
  assert_failure
  assert_output --partial "wrappingKeyId is required for mode remote"
}

@test "kas-keys: create key (provider mode, missing wrappingKeyId)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kasId "${KAS_REGISTRY_ID}" --keyId "${KEY_ID}" --alg "rsa:2048" --mode "provider" --providerConfigId "pc-1"
  assert_failure
  assert_output --partial "wrappingKeyId is required for mode provider"
}

@test "kas-keys: create key (provider mode, missing providerConfigId)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kasId "${KAS_REGISTRY_ID}" --keyId "${KEY_ID}" --alg "rsa:2048" --mode "provider" --wrappingKeyId "wk-1"
  assert_failure
  assert_output --partial "providerConfigId is required for mode provider"
}

@test "kas-keys: create key (remote mode, pem not base64)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kasId "${KAS_REGISTRY_ID}" --keyId "${KEY_ID}" --alg "rsa:2048" --mode "remote" --pubPem "not-base64-value" --providerConfigId "pc-1" --wrappingKeyId "wk-1"
  assert_failure
  assert_output --partial "pem must be base64 encoded"
}

@test "kas-keys: create key (public_key mode, pem not base64)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kasId "${KAS_REGISTRY_ID}" --keyId "${KEY_ID}" --alg "rsa:2048" --mode "public_key" --pubPem "not-base64-value"
  assert_failure
  assert_output --partial "pem must be base64 encoded"
}

@test "kas-keys: create key (missing kas identifier - kasId, kasName, or kasUri)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --keyId "${KEY_ID}" --alg "rsa:2048" --mode "public_key" --pubPem "${PEM_B64}"
  assert_failure
  assert_output --partial "Error: at least one of the flags in the group [kasId kasUri kasName] is required"
}

@test "kas-keys: create key (using kasName)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kasName "${KAS_NAME}" --keyId "${KEY_ID}" --alg "rsa:2048" --mode "public_key" --pubPem "${PEM_B64}" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r .kas_id)" "${KAS_REGISTRY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_id)" "${KEY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_algorithm)" "1" # rsa:2048
  assert_equal "$(echo "$output" | jq -r .key.key_mode)" "4"    # public_key
  assert_equal "$(echo "$output" | jq -r .key.key_status)" "1"   # active
  assert_equal "$(echo "$output" | jq -r .key.public_key_ctx.pem)" "${PEM_B64}"
  assert_equal "$(echo "$output" | jq -r .key.private_key_ctx)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.created_at)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.updated_at)" "null"
}

@test "kas-keys: create key (using kasUri)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kasUri "${KAS_URI}" --keyId "${KEY_ID}" --alg "rsa:2048" --mode "public_key" --pubPem "${PEM_B64}" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r .kas_id)" "${KAS_REGISTRY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_id)" "${KEY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_algorithm)" "1" # rsa:2048
  assert_equal "$(echo "$output" | jq -r .key.key_mode)" "4"    # public_key
  assert_equal "$(echo "$output" | jq -r .key.key_status)" "1"   # active
  assert_equal "$(echo "$output" | jq -r .key.public_key_ctx.pem)" "${PEM_B64}"
  assert_equal "$(echo "$output" | jq -r .key.private_key_ctx)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.created_at)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.updated_at)" "null"
}

@test "kas-keys: create key (mutually exclusive KAS identifiers)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kasId "${KAS_REGISTRY_ID}" --kasName "some-other-kas" --keyId "${KEY_ID}" --alg "rsa:2048" --mode "public_key" --pubPem "${PEM_B64}" --json
  assert_failure
  assert_output --partial "Error: if any flags in the group [kasId kasUri kasName] are set none of the others can be; [kasId kasName] were all set"
}

@test "kas-keys: create key (invalid algorithm value)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kasId "${KAS_REGISTRY_ID}" --keyId "${KEY_ID}" --alg "invalid-algorithm-value" --mode "public_key" --pubPem "${PEM_B64}" --json
  assert_failure
  assert_output --partial "Invalid algorithm"
}

@test "kas-keys: create key (invalid mode value)" {
  KEY_ID=$(generate_key_id)
  run_otdfctl_key create --kasId "${KAS_REGISTRY_ID}" --keyId "${KEY_ID}" --alg "rsa:2048" --mode "invalid-mode-value" --pubPem "${PEM_B64}" --json
  assert_failure
  assert_output --partial "Invalid mode"
}

@test "kas-keys: get key by system ID" {
  KEY_ID_GET=$(generate_key_id)
  run_otdfctl_key create --kasId "${KAS_REGISTRY_ID}" --keyId "${KEY_ID_GET}" --alg "rsa:2048" --mode "public_key" --pubPem "${PEM_B64}" --json
  assert_success
  CREATED_KEY_SYSTEM_ID=$(echo "$output" | jq -r .key.id)

  run_otdfctl_key get --id "${CREATED_KEY_SYSTEM_ID}" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r .kas_id)" "${KAS_REGISTRY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.id)" "${CREATED_KEY_SYSTEM_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_id)" "${KEY_ID_GET}"
  assert_equal "$(echo "$output" | jq -r .key.key_algorithm)" "1" # rsa:2048
  assert_equal "$(echo "$output" | jq -r .key.key_mode)" "4"    # public_key
  assert_equal "$(echo "$output" | jq -r .key.key_status)" "1"   # active
  assert_equal "$(echo "$output" | jq -r .key.public_key_ctx.pem)" "${PEM_B64}"
  assert_equal "$(echo "$output" | jq -r .key.private_key_ctx)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.created_at)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.updated_at)" "null"
}

@test "kas-keys: get key by user keyId and kasId" {
  KEY_ID_GET_USER=$(generate_key_id)
  # Using ec:secp256r1 and public_key mode for variety
  run_otdfctl_key create --kasId "${KAS_REGISTRY_ID}" --keyId "${KEY_ID_GET_USER}" --alg "ec:secp256r1" --mode "public_key" --pubPem "${PEM_B64}" --json
  assert_success
  local created_key_system_id_for_get=$(echo "$output" | jq -r .key.id)

  run_otdfctl_key get --keyId "${KEY_ID_GET_USER}" --kasId "${KAS_REGISTRY_ID}" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r .kas_id)" "${KAS_REGISTRY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.id)" "${created_key_system_id_for_get}"
  assert_equal "$(echo "$output" | jq -r .key.key_id)" "${KEY_ID_GET_USER}"
  assert_equal "$(echo "$output" | jq -r .key.key_algorithm)" "3" # ec:secp256r1
  assert_equal "$(echo "$output" | jq -r .key.key_mode)" "4"    # public_key
  assert_equal "$(echo "$output" | jq -r .key.key_status)" "1"   # active
  assert_equal "$(echo "$output" | jq -r .key.public_key_ctx.pem)" "${PEM_B64}"
  assert_equal "$(echo "$output" | jq -r .key.private_key_ctx)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.created_at)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.updated_at)" "null"
}

@test "kas-keys: get key by user keyId and kasName" {
  KEY_ID_GET_USER_KASNAME=$(generate_key_id)
  run_otdfctl_key create --kasName "kas-registry-for-keys-test" --keyId "${KEY_ID_GET_USER_KASNAME}" --alg "rsa:2048" --mode "public_key" --pubPem "${PEM_B64}" --json
  assert_success
  local created_key_system_id_for_kasname_get=$(echo "$output" | jq -r .key.id)

  run_otdfctl_key get --keyId "${KEY_ID_GET_USER_KASNAME}" --kasName "kas-registry-for-keys-test" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r .kas_id)" "${KAS_REGISTRY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.id)" "${created_key_system_id_for_kasname_get}"
  assert_equal "$(echo "$output" | jq -r .key.key_id)" "${KEY_ID_GET_USER_KASNAME}"
  assert_equal "$(echo "$output" | jq -r .key.key_algorithm)" "1" # rsa:2048
  assert_equal "$(echo "$output" | jq -r .key.key_mode)" "4"    # public_key
  assert_equal "$(echo "$output" | jq -r .key.key_status)" "1"   # active
  assert_equal "$(echo "$output" | jq -r .key.public_key_ctx.pem)" "${PEM_B64}"
  assert_equal "$(echo "$output" | jq -r .key.private_key_ctx)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.created_at)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.updated_at)" "null"
}

@test "kas-keys: get key by user keyId and kasUri" {
  KEY_ID_GET_USER_KASURI=$(generate_key_id)
  run_otdfctl_key create --kasUri "${KAS_URI}" --keyId "${KEY_ID_GET_USER_KASURI}" --alg "ec:secp256r1" --mode "public_key" --pubPem "${PEM_B64}" --json
  assert_success
  local created_key_system_id_for_kasuri_get=$(echo "$output" | jq -r .key.id)

  run_otdfctl_key get --keyId "${KEY_ID_GET_USER_KASURI}" --kasUri "${KAS_URI}" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r .kas_id)" "${KAS_REGISTRY_ID}" # Should resolve to the same KAS
  assert_equal "$(echo "$output" | jq -r .key.id)" "${created_key_system_id_for_kasuri_get}"
  assert_equal "$(echo "$output" | jq -r .key.key_id)" "${KEY_ID_GET_USER_KASURI}"
  assert_equal "$(echo "$output" | jq -r .key.key_algorithm)" "3" # ec:secp256r1
  assert_equal "$(echo "$output" | jq -r .key.key_mode)" "4"    # public_key
  assert_equal "$(echo "$output" | jq -r .key.key_status)" "1"   # active
  assert_equal "$(echo "$output" | jq -r .key.public_key_ctx.pem)" "${PEM_B64}"
  assert_equal "$(echo "$output" | jq -r .key.private_key_ctx)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.created_at)" "null"
  assert_not_equal "$(echo "$output" | jq -r .key.metadata.updated_at)" "null"
}

@test "kas-keys: get key (failure: only keyId, missing KAS identifier)" {
  KEY_ID_FAIL_GET=$(generate_key_id)
  # Create a key first so it potentially exists, though the failure should be due to missing KAS context for the get
  run_otdfctl_key create --kasId "${KAS_REGISTRY_ID}" --keyId "${KEY_ID_FAIL_GET}" --alg "rsa:2048" --mode "public_key" --pubPem "${PEM_B64}" --json
  assert_success

  run_otdfctl_key get --keyId "${KEY_ID_FAIL_GET}" --json
  assert_failure
  # Error message might vary, but it should indicate an issue with resolving the key or missing parameters
  assert_output --partial "Failed to get kas key" # Or a more specific error about missing KAS identifier
}

@test "kas-keys: get key (failure: only kasId, missing keyId or system id)" {
  run_otdfctl_key get --kasId "${KAS_REGISTRY_ID}" --json
  assert_failure
  # This should fail because neither system --id nor user --key-id is provided
  assert_output --partial "Failed to get kas key" # Or a specific error about missing key identifier
}

@test "kas-keys: get key (not found by system ID)" {
  run_otdfctl_key get --id "39af808f-6cac-403f-90d7-6b88e865860d" --json
  assert_failure
  assert_output --partial "Failed to get kas key" # Error should indicate not found or similar
}

@test "kas-keys: get key (not found by user keyId and kasId)" {
  run_otdfctl_key get --keyId "non-existent-key" --kasId "${KAS_REGISTRY_ID}" --json
  assert_failure
  assert_output --partial "Failed to get kas key" # Error should indicate not found or similar
}

@test "kas-keys: get key (mutually exclusive: id and keyId)" {
  run_otdfctl_key get --id "some-system-id" --keyId "some-user-key-id" --kasId "${KAS_REGISTRY_ID}" --json
  assert_failure
  assert_output --partial "Error: if any flags in the group [id keyId] are set none of the others can be"
}

@test "kas-keys: get key (mutually exclusive: kasId and kasName with keyId)" {
  run_otdfctl_key get --keyId "some-user-key-id" --kasId "${KAS_REGISTRY_ID}" --kasName "some-kas-name" --json
  assert_failure
  assert_output --partial "Error: if any flags in the group [kasUri kasId kasName] are set none of the others can be; [kasId kasName] were all set"
}

@test "kas-keys: update key labels (add)" {
  KEY_ID_UPDATE_LABEL=$(generate_key_id)
  run_otdfctl_key create --kasId "${KAS_REGISTRY_ID}" --keyId "${KEY_ID_UPDATE_LABEL}" --alg "rsa:2048" --mode "public_key" --pubPem "${PEM_B64}" --label "initial=true" --json
  assert_success
  UPDATE_KEY_LABEL_SYSTEM_ID=$(echo "$output" | jq -r .key.id)
  local initial_created_at_seconds=$(echo "$output" | jq -r .key.metadata.created_at.seconds)
  local initial_updated_at_seconds=$(echo "$output" | jq -r .key.metadata.updated_at.seconds)

  run_otdfctl_key update --id "${UPDATE_KEY_LABEL_SYSTEM_ID}" --label "added=true" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r .kas_id)" "${KAS_REGISTRY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.id)" "${UPDATE_KEY_LABEL_SYSTEM_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_id)" "${KEY_ID_UPDATE_LABEL}"
  assert_equal "$(echo "$output" | jq -r .key.key_algorithm)" "1" # rsa:2048
  assert_equal "$(echo "$output" | jq -r .key.key_mode)" "4"    # public_key
  assert_equal "$(echo "$output" | jq -r .key.key_status)" "1"   # active (should not change)
  assert_equal "$(echo "$output" | jq -r .key.public_key_ctx.pem)" "${PEM_B64}"
  assert_equal "$(echo "$output" | jq -r .key.private_key_ctx)" "null"
  assert_equal "$(echo "$output" | jq -r '.key.metadata.labels."initial"')" "true"
  assert_equal "$(echo "$output" | jq -r '.key.metadata.labels."added"')" "true"
  assert_equal "$(echo "$output" | jq -r .key.metadata.created_at.seconds)" "${initial_created_at_seconds}" # created_at should not change

  # Verify with a subsequent get
  run_otdfctl_key get --id "${UPDATE_KEY_LABEL_SYSTEM_ID}" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r '.key.metadata.labels."initial"')" "true"
  assert_equal "$(echo "$output" | jq -r '.key.metadata.labels."added"')" "true"
}

@test "kas-keys: update key labels (replace)" {
  KEY_ID_UPDATE_LABEL_REPLACE=$(generate_key_id)
  run_otdfctl_key create --kasId "${KAS_REGISTRY_ID}" --keyId "${KEY_ID_UPDATE_LABEL_REPLACE}" --alg "rsa:2048" --mode "public_key" --pubPem "${PEM_B64}" --label "initial=true" --json
  assert_success
  UPDATE_KEY_LABEL_REPLACE_SYSTEM_ID=$(echo "$output" | jq -r .key.id)
  local initial_created_at_replace_seconds=$(echo "$output" | jq -r .key.metadata.created_at.seconds)


  run_otdfctl_key update --id "${UPDATE_KEY_LABEL_REPLACE_SYSTEM_ID}" --label "replaced=true" --force-replace-labels --json
  assert_success
  assert_equal "$(echo "$output" | jq -r .kas_id)" "${KAS_REGISTRY_ID}"
  assert_equal "$(echo "$output" | jq -r .key.id)" "${UPDATE_KEY_LABEL_REPLACE_SYSTEM_ID}"
  assert_equal "$(echo "$output" | jq -r .key.key_id)" "${KEY_ID_UPDATE_LABEL_REPLACE}"
  assert_equal "$(echo "$output" | jq -r .key.key_algorithm)" "1" # rsa:2048
  assert_equal "$(echo "$output" | jq -r .key.key_mode)" "4"    # public_key
  assert_equal "$(echo "$output" | jq -r .key.key_status)" "1"   # active
  assert_equal "$(echo "$output" | jq -r '.key.metadata.labels."replaced"')" "true"
  assert_equal "$(echo "$output" | jq -r '.key.metadata.labels."initial" // "null"')" "null"
  assert_equal "$(echo "$output" | jq -r .key.metadata.created_at.seconds)" "${initial_created_at_replace_seconds}"

  # Verify with a subsequent get
  run_otdfctl_key get --id "${UPDATE_KEY_LABEL_REPLACE_SYSTEM_ID}" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r '.key.metadata.labels."replaced"')" "true"
  assert_equal "$(echo "$output" | jq -r '.key.metadata.labels."initial" // "null"')" "null"
}

@test "kas-keys: update key (not found)" {
  run_otdfctl_key update --id "39af808f-6cac-403f-90d7-6b88e865860d" --json
  assert_failure
  assert_output --partial "Failed to update kas key"
}

@test "kas-keys: update key (missing id)" {
  run_otdfctl_key update --json
  assert_failure
  assert_output --partial "ERROR    Flag '--id' is required"
}

# LIST Tests
@test "kas-keys: list keys (default limit and offset)" {
  # Create a few keys to ensure there\\'s something to list and to check structure
  KEY_ID_LIST_1=$(generate_key_id)

  run_otdfctl_key create --kasId "${KAS_REGISTRY_ID}" --keyId "${KEY_ID_LIST_1}" --alg "rsa:2048" --mode "public_key" --pubPem "${PEM_B64}" --json
  assert_success
  local key1_system_id=$(echo "$output" | jq -r .key.id)

  KEY_ID_LIST_2=$(generate_key_id)
  run_otdfctl_key create --kasId "${KAS_REGISTRY_ID}" --keyId "${KEY_ID_LIST_2}" --alg "ec:secp256r1" --mode "public_key" --pubPem "${PEM_B64}" --json
  assert_success
  local key2_system_id=$(echo "$output" | jq -r .key.id)

  run_otdfctl_key list --json
  assert_success

  # For key1:
  assert_equal "$(echo "$output" | jq -r --arg id "${key1_system_id}" '.[] | select(.key.id == $id) | .key.id')" "${key1_system_id}"
  assert_equal "$(echo "$output" | jq -r --arg id "${key1_system_id}" '.[] | select(.key.id == $id) | .key.key_id')" "${KEY_ID_LIST_1}"
  assert_equal "$(echo "$output" | jq -r --arg id "${key1_system_id}" '.[] | select(.key.id == $id) | .key.key_algorithm')" "1"
  assert_equal "$(echo "$output" | jq -r --arg id "${key1_system_id}" '.[] | select(.key.id == $id) | .key.key_mode')" "4"
  assert_equal "$(echo "$output" | jq -r --arg id "${key1_system_id}" '.[] | select(.key.id == $id) | .key.key_status')" "1"
  assert_equal "$(echo "$output" | jq -r --arg id "${key1_system_id}" '.[] | select(.key.id == $id) | .key.public_key_ctx.pem')" "${PEM_B64}"
  assert_equal "$(echo "$output" | jq -r --arg id "${key1_system_id}" '.[] | select(.key.id == $id) | .key.private_key_ctx')" "null"
  assert_not_equal "$(echo "$output" | jq -r --arg id "${key1_system_id}" '.[] | select(.key.id == $id) | .key.metadata.created_at')" "null"
  assert_not_equal "$(echo "$output" | jq -r --arg id "${key1_system_id}" '.[] | select(.key.id == $id) | .key.metadata.updated_at')" "null"

  # For key2:
  assert_equal "$(echo "$output" | jq -r --arg id "${key2_system_id}" '.[] | select(.key.id == $id) | .key.id')" "${key2_system_id}"
  assert_equal "$(echo "$output" | jq -r --arg id "${key2_system_id}" '.[] | select(.key.id == $id) | .key.key_id')" "${KEY_ID_LIST_2}"
  assert_equal "$(echo "$output" | jq -r --arg id "${key2_system_id}" '.[] | select(.key.id == $id) | .key.key_algorithm')" "3"
  assert_equal "$(echo "$output" | jq -r --arg id "${key2_system_id}" '.[] | select(.key.id == $id) | .key.key_mode')" "4"
  assert_equal "$(echo "$output" | jq -r --arg id "${key2_system_id}" '.[] | select(.key.id == $id) | .key.key_status')" "1"
  assert_equal "$(echo "$output" | jq -r --arg id "${key2_system_id}" '.[] | select(.key.id == $id) | .key.public_key_ctx.pem')" "${PEM_B64}"
  assert_equal "$(echo "$output" | jq -r --arg id "${key2_system_id}" '.[] | select(.key.id == $id) | .key.private_key_ctx')" "null"
  assert_not_equal "$(echo "$output" | jq -r --arg id "${key2_system_id}" '.[] | select(.key.id == $id) | .key.metadata.created_at')" "null"
  assert_not_equal "$(echo "$output" | jq -r --arg id "${key2_system_id}" '.[] | select(.key.id == $id) | .key.metadata.updated_at')" "null"
}

@test "kas-keys: list keys (pagination with limit and offset)" {
  KAS_NAME_LIST=$(generate_kas_name)
  KAS_URI_LIST=$(format_kas_name_as_uri "${KAS_NAME_LIST}")
  KAS_ID_LIST=$(./otdfctl $HOST $WITH_CREDS policy kas-registry create --name "$KAS_NAME_LIST" --uri "$KAS_URI_LIST" --public-key-remote 'https://test-kas-with-keys.com' --json | jq -r '.id')
  assert_not_equal "$KAS_ID_LIST" ""

  # Create a known set of keys for pagination testing
  local key_p1_id=$(generate_key_id)
  run_otdfctl_key create --kasId "${KAS_ID_LIST}" --keyId "${key_p1_id}" --alg "rsa:4096" --mode "public_key" --pubPem "${PEM_B64}" --json
  assert_success
  local key_p1_sys_id=$(echo "$output" | jq -r .key.id)

  local key_p2_id=$(generate_key_id)
  run_otdfctl_key create --kasId "${KAS_ID_LIST}" --keyId "${key_p2_id}" --alg "ec:secp256r1" --mode "public_key" --pubPem "${PEM_B64}" --json
  assert_success
  local key_p2_sys_id=$(echo "$output" | jq -r .key.id)

  local key_p3_id=$(generate_key_id)
  run_otdfctl_key create --kasId "${KAS_ID_LIST}" --keyId "${key_p3_id}" --alg "rsa:2048" --mode "public_key" --pubPem "${PEM_B64}" --json
  assert_success
  local key_p3_sys_id=$(echo "$output" | jq -r .key.id)

  # Test: limit 1, offset 0 - should get the first key (order dependent on server, so we check for one of them)
  run_otdfctl_key list --kasId "${KAS_ID_LIST}" --limit 1 --offset 0 --json
  assert_success
  assert_equal "$(echo "$output" | jq '. | length')" "1"
  local found_id_limit1_offset0=$(echo "$output" | jq -r '.[0].key.id')

  # Test: limit 1, offset 1 - should get the second key
  run_otdfctl_key list --kasId "${KAS_ID_LIST}" --limit 1 --offset 1 --json
  assert_success
  assert_equal "$(echo "$output" | jq '. | length')" "1"
  local found_id_limit1_offset1=$(echo "$output" | jq -r '.[0].key.id')
  assert_not_equal "${found_id_limit1_offset1}" "${found_id_limit1_offset0}"


  run_otdfctl_key list --kasId "${KAS_ID_LIST}" --limit 3 --offset 0 --json # Fetch up to 3
  assert_success
  local count_limit3_offset0=$(echo "$output" | jq '. | length')
  assert_equal "${count_limit3_offset0}" 3
  assert_equal "$(echo "$output" | jq -r --arg id "${key_p1_sys_id}" '.[] | select(.key.id == $id) | .key.id')" "${key_p1_sys_id}"
  assert_equal "$(echo "$output" | jq -r --arg id "${key_p2_sys_id}" '.[] | select(.key.id == $id) | .key.id')" "${key_p2_sys_id}"
  assert_equal "$(echo "$output" | jq -r --arg id "${key_p3_sys_id}" '.[] | select(.key.id == $id) | .key.id')" "${key_p3_sys_id}"


  # Test: limit 1, offset (large number, e.g., 100) - should get 0 keys
  run_otdfctl_key list --kasId "${KAS_ID_LIST}" --limit 1 --offset 100 --json
  assert_success
  assert_equal "$(echo "$output" | jq '. | length')" "0"
}

@test "kas-keys: list keys (filter by alg rsa:2048)" {
  KAS_NAME_LIST=$(generate_kas_name)
  KAS_URI_LIST=$(format_kas_name_as_uri "${KAS_NAME_LIST}")
  KAS_ID_LIST=$(./otdfctl $HOST $WITH_CREDS policy kas-registry create --name "$KAS_NAME_LIST" --uri "$KAS_URI_LIST" --public-key-remote 'https://test-kas-with-keys.com' --json | jq -r '.id')
  assert_not_equal "$KAS_ID_LIST" ""

  # Ensure at least one rsa:2048 key exists for this KAS
  KEY_ID_LIST_RSA=$(generate_key_id)
  run_otdfctl_key create --kasId "${KAS_ID_LIST}" --keyId "${KEY_ID_LIST_RSA}" --alg "rsa:2048" --mode "public_key" --pubPem "${PEM_B64}" --json
  assert_success
  local rsa_key_sys_id=$(echo "$output" | jq -r .key.id)

  # Ensure at least one non-rsa:2048 key exists for this KAS to test filtering
  KEY_ID_LIST_EC=$(generate_key_id)
  run_otdfctl_key create --kasId "${KAS_ID_LIST}" --keyId "${KEY_ID_LIST_EC}" --alg "ec:secp256r1" --mode "public_key" --pubPem "${PEM_B64}" --json
  assert_success
  local ec_key_sys_id=$(echo "$output" | jq -r .key.id)


  run_otdfctl_key list --kasId "${KAS_ID_LIST}" --alg "rsa:2048" --json
  assert_success
  # Every key in the list should be rsa:2048
  # And our specific RSA key should be present
  assert_equal "$(echo "$output" | jq -r --arg id "${rsa_key_sys_id}" '.[] | select(.key.id == $id) | .key.id')" "${rsa_key_sys_id}"
  assert_equal "$(echo "$output" | jq -r --arg id "${rsa_key_sys_id}" '.[] | select(.key.id == $id) | .key.key_id')" "${KEY_ID_LIST_RSA}"
  assert_equal "$(echo "$output" | jq -r --arg id "${rsa_key_sys_id}" '.[] | select(.key.id == $id) | .key.key_algorithm')" "1"
  assert_equal "$(echo "$output" | jq -r --arg id "${rsa_key_sys_id}" '.[] | select(.key.id == $id) | .key.key_mode')" "4"
  assert_equal "$(echo "$output" | jq -r --arg id "${rsa_key_sys_id}" '.[] | select(.key.id == $id) | .key.key_status')" "1"
  assert_equal "$(echo "$output" | jq -r --arg id "${rsa_key_sys_id}" '.[] | select(.key.id == $id) | .key.public_key_ctx.pem')" "${PEM_B64}"
  assert_equal "$(echo "$output" | jq -r --arg id "${rsa_key_sys_id}" '.[] | select(.key.id == $id) | .key.private_key_ctx')" "null"
  assert_not_equal "$(echo "$output" | jq -r --arg id "${rsa_key_sys_id}" '.[] | select(.key.id == $id) | .key.metadata.created_at')" "null"
  assert_not_equal "$(echo "$output" | jq -r --arg id "${rsa_key_sys_id}" '.[] | select(.key.id == $id) | .key.metadata.updated_at')" "null"

  # Check that all listed keys have key_algorithm 1 (ALGORITHM_RSA_2048)
  local count_non_rsa=$(echo "$output" | jq '[.[] | select(.key.key_algorithm != 1)] | length')
  assert_equal "$count_non_rsa" "0"
}

@test "kas-keys: list keys (filter by kasId)" {
  KAS_NAME_LIST=$(generate_kas_name)
  KAS_URI_LIST=$(format_kas_name_as_uri "${KAS_NAME_LIST}")
  KAS_ID_LIST=$(./otdfctl $HOST $WITH_CREDS policy kas-registry create --name "$KAS_NAME_LIST" --uri "$KAS_URI_LIST" --public-key-remote 'https://test-kas-with-keys.com' --json | jq -r '.id')
  assert_not_equal "$KAS_ID_LIST" ""

  KEY_ID_LIST_KAS_FILTER=$(generate_key_id)
  run_otdfctl_key create --kasId "${KAS_ID_LIST}" --keyId "${KEY_ID_LIST_KAS_FILTER}" --alg "rsa:2048" --mode "public_key" --pubPem "${PEM_B64}" --json
  assert_success
  local kas_filter_key_sys_id=$(echo "$output" | jq -r .key.id)

  # List keys for the new KAS
  run_otdfctl_key list --kasId "${KAS_ID_LIST}" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r '.[0].kas_id')" "${KAS_ID_LIST}"
  assert_equal "$(echo "$output" | jq -r '.[0].key.id')" "${kas_filter_key_sys_id}"
  assert_equal "$(echo "$output" | jq -r '.[0].key.key_id')" "${KEY_ID_LIST_KAS_FILTER}"
  assert_equal "$(echo "$output" | jq -r '.[0].key.key_algorithm')" "1"
  assert_equal "$(echo "$output" | jq -r '.[0].key.key_mode')" "4"
  assert_equal "$(echo "$output" | jq -r '.[0].key.key_status')" "1"
  assert_equal "$(echo "$output" | jq -r '.[0].key.public_key_ctx.pem')" "${PEM_B64}"
  assert_equal "$(echo "$output" | jq -r '.[0].key.private_key_ctx')" "null"
  assert_not_equal "$(echo "$output" | jq -r '.[0].key.metadata.created_at')" "null"
  assert_not_equal "$(echo "$output" | jq -r '.[0].key.metadata.updated_at')" "null"
  assert_equal "$(echo "$output" | jq '. | length')" "1"


  # List keys for the default KAS_REGISTRY_ID and ensure the new key is not present
  run_otdfctl_key list --kasId "${KAS_REGISTRY_ID}" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r --arg id "${kas_filter_key_sys_id}" '[.[] | select(.key.id == $id)] | length')" "0"
}

@test "kas-keys: list keys (filter by kasName)" {
  KAS_NAME_LIST=$(generate_kas_name)
  echo "DEBUG: KAS_NAME_LIST: ${KAS_NAME_LIST}" >&2
  KAS_URI_LIST=$(format_kas_name_as_uri "${KAS_NAME_LIST}")
  KAS_ID_LIST=$(./otdfctl $HOST $WITH_CREDS policy kas-registry create --name "$KAS_NAME_LIST" --uri "$KAS_URI_LIST" --public-key-remote 'https://test-kas-with-keys.com' --json | jq -r '.id')
  assert_not_equal "$KAS_ID_LIST" ""

  KEY_ID_LIST_KAS_NAME_FILTER=$(generate_key_id)
  local lower_kas_name=$(echo "${KAS_NAME_LIST}" | tr '[:upper:]' '[:lower:]')
  run_otdfctl_key create --kasName "${lower_kas_name}" --keyId "${KEY_ID_LIST_KAS_NAME_FILTER}" --alg "rsa:2048" --mode "public_key" --pubPem "${PEM_B64}" --json
  assert_success
  local kas_name_filter_key_sys_id=$(echo "$output" | jq -r .key.id)

  run_otdfctl_key list --kasName "${lower_kas_name}"  --json
  assert_success
  assert_equal "$(echo "$output" | jq -r '.[0].kas_id')" "${KAS_ID_LIST}"
  assert_equal "$(echo "$output" | jq -r '.[0].key.id')" "${kas_name_filter_key_sys_id}"
  assert_equal "$(echo "$output" | jq -r '.[0].key.key_id')" "${KEY_ID_LIST_KAS_NAME_FILTER}"
  assert_equal "$(echo "$output" | jq -r '.[0].key.key_algorithm')" "1"
  assert_equal "$(echo "$output" | jq -r '.[0].key.key_mode')" "4"
  assert_equal "$(echo "$output" | jq -r '.[0].key.key_status')" "1"
  assert_equal "$(echo "$output" | jq -r '.[0].key.public_key_ctx.pem')" "${PEM_B64}"
  assert_equal "$(echo "$output" | jq -r '.[0].key.private_key_ctx')" "null"
  assert_not_equal "$(echo "$output" | jq -r '.[0].key.metadata.created_at')" "null"
  assert_not_equal "$(echo "$output" | jq -r '.[0].key.metadata.updated_at')" "null"
}

@test "kas-keys: list keys (filter by kasUri)" {
  # This command is not a 'kas-registry key' subcommand, so it won't use run_otdfctl_key
  KAS_NAME_LIST=$(generate_kas_name)
  KAS_URI_LIST=$(format_kas_name_as_uri "${KAS_NAME_LIST}")
  KAS_ID_LIST=$(./otdfctl $HOST $WITH_CREDS policy kas-registry create --name "$KAS_NAME_LIST" --uri "$KAS_URI_LIST" --public-key-remote 'https://test-kas-with-keys.com' --json | jq -r '.id')
  assert_not_equal "$KAS_ID_LIST" ""

  KEY_ID_LIST_KAS_URI_FILTER=$(generate_key_id)
  run_otdfctl_key create --kasUri "${KAS_URI_LIST}" --keyId "${KEY_ID_LIST_KAS_URI_FILTER}" --alg "rsa:2048" --mode "public_key" --pubPem "${PEM_B64}" --json
  assert_success
  local kas_uri_filter_key_sys_id=$(echo "$output" | jq -r .key.id)

  run_otdfctl_key list --kasUri "${KAS_URI_LIST}" --json
  assert_success
  assert_equal "$(echo "$output" | jq -r '.[0].kas_id')" "${KAS_ID_LIST}"
  assert_equal "$(echo "$output" | jq -r '.[0].key.id')" "${kas_uri_filter_key_sys_id}"
  assert_equal "$(echo "$output" | jq -r '.[0].key.key_id')" "${KEY_ID_LIST_KAS_URI_FILTER}"
  assert_equal "$(echo "$output" | jq -r '.[0].key.key_algorithm')" "1"
  assert_equal "$(echo "$output" | jq -r '.[0].key.key_mode')" "4"
  assert_equal "$(echo "$output" | jq -r '.[0].key.key_status')" "1"
  assert_equal "$(echo "$output" | jq -r '.[0].key.public_key_ctx.pem')" "${PEM_B64}"
}

@test "kas-keys: list keys (invalid alg)" {
  run_otdfctl_key list --alg "invalid-alg" --json
  assert_failure
  assert_output --partial "Invalid algorithm"
}

@test "kas-keys: list keys (mutually exclusive: kasId and kasName)" {
  run_otdfctl_key list --kasId "${KAS_REGISTRY_ID}" --kasName "some-kas-name" --json
  assert_failure
  assert_output --partial "Error: if any flags in the group [kasId kasName kasUri] are set none of the others can be"
}
