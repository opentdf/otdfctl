// Code generated by adder. DO NOT EDIT.

package encrypt

import (
	"fmt"
	
	"github.com/spf13/cobra"
)

// EncryptRequestFlags represents the flags for the encrypt [file] command
type EncryptRequestFlags struct {
	Out string `json:"out"` // The output file TDF in the current working directory instead of stdout ('-o file.txt' and '-o file.txt.tdf' both write the TDF as file.txt.tdf).
	Attr string `json:"attr"` // Attribute value Fully Qualified Names (FQNs, i.e. 'https://example.com/attr/attr1/value/value1') to apply to the encrypted data.
	WrappingKeyAlgorithm string `json:"wrappingKeyAlgorithm" validate:"oneof=rsa:2048 ec:secp256r1 ec:secp384r1 ec:secp521r1"` // EXPERIMENTAL: The algorithm to use for the wrapping key 

	MimeType string `json:"mimeType"` // The MIME type of the input data. If not provided, the MIME type is inferred from the input data.
	TdfType string `json:"tdfType" validate:"oneof=ztdf tdf3 nano"` // The type of tdf to encrypt as. ZTDF supports structured manifests and larger payloads. NanoTDF has a smaller footprint and more performant, but does not support structured manifests or large payloads. (tdf3 is an alias for ztdf)
	EcdsaBinding string `json:"ecdsaBinding"` // For nano type containers only, enables ECDSA policy binding
	KasUrlPath string `json:"kasUrlPath"` // URL path to the KAS service at the platform endpoint domain. Leading slash is required if needed.
	TargetMode string `json:"targetMode"` // The target TDF spec version (e.g., \"4.3.0\"); intended for legacy compatibility and subject to removal.
	WithAssertions string `json:"withAssertions"` // EXPERIMENTAL: JSON string or path to a JSON file of assertions to bind metadata to the TDF. See examples for more information. WARNING: Providing keys in a JSON string is strongly discouraged. If including sensitive keys, instead provide a path to a JSON file containing that information.
}

// EncryptRequest represents the parameters for the encrypt [file] command
type EncryptRequest struct {
	Flags EncryptRequestFlags `json:"flags"`
}

// EncryptHandler defines the function type for handling encrypt [file] commands
type EncryptHandler func(cmd *cobra.Command, req *EncryptRequest) error

// NewEncryptCommand creates a new encrypt [file] command with the provided handler function
func NewEncryptCommand(handler EncryptHandler) *cobra.Command {
	cmd := &cobra.Command{
		Use:     "encrypt",
		Short:   "Encrypt file or stdin as a TDF",
		RunE: func(cmd *cobra.Command, args []string) error {
			return runEncrypt(cmd, args, handler)
		},
	}

	// Register flags
	cmd.Flags().StringP("out", "o", "", "The output file TDF in the current working directory instead of stdout ('-o file.txt' and '-o file.txt.tdf' both write the TDF as file.txt.tdf).")
	cmd.Flags().StringP("attr", "a", "", "Attribute value Fully Qualified Names (FQNs, i.e. 'https://example.com/attr/attr1/value/value1') to apply to the encrypted data.")
	cmd.Flags().String("wrapping-key-algorithm", "rsa:2048", "EXPERIMENTAL: The algorithm to use for the wrapping key")
	cmd.Flags().String("mime-type", "", "The MIME type of the input data. If not provided, the MIME type is inferred from the input data.")
	cmd.Flags().StringP("tdf-type", "t", "ztdf", "The type of tdf to encrypt as. ZTDF supports structured manifests and larger payloads. NanoTDF has a smaller footprint and more performant, but does not support structured manifests or large payloads. (tdf3 is an alias for ztdf)")
	cmd.Flags().String("ecdsa-binding", "", "For nano type containers only, enables ECDSA policy binding")
	cmd.Flags().String("kas-url-path", "/kas", "URL path to the KAS service at the platform endpoint domain. Leading slash is required if needed.")
	cmd.Flags().String("target-mode", "", "The target TDF spec version (e.g., \"4.3.0\"); intended for legacy compatibility and subject to removal.")
	cmd.Flags().String("with-assertions", "", "EXPERIMENTAL: JSON string or path to a JSON file of assertions to bind metadata to the TDF. See examples for more information. WARNING: Providing keys in a JSON string is strongly discouraged. If including sensitive keys, instead provide a path to a JSON file containing that information.")

	return cmd
}

// runEncrypt handles argument and flag extraction
func runEncrypt(cmd *cobra.Command, args []string, handler EncryptHandler) error {
	out, _ := cmd.Flags().GetString("out")
	attr, _ := cmd.Flags().GetString("attr")
	wrappingKeyAlgorithm, _ := cmd.Flags().GetString("wrapping-key-algorithm")
	mimeType, _ := cmd.Flags().GetString("mime-type")
	tdfType, _ := cmd.Flags().GetString("tdf-type")
	ecdsaBinding, _ := cmd.Flags().GetString("ecdsa-binding")
	kasUrlPath, _ := cmd.Flags().GetString("kas-url-path")
	targetMode, _ := cmd.Flags().GetString("target-mode")
	withAssertions, _ := cmd.Flags().GetString("with-assertions")
	// Validate enum for wrapping-key-algorithm
	wrappingKeyAlgorithmValid := false
	for _, validValue := range []string{"rsa:2048", "ec:secp256r1", "ec:secp384r1", "ec:secp521r1"} {
		if wrappingKeyAlgorithm == validValue {
			wrappingKeyAlgorithmValid = true
			break
		}
	}
	if !wrappingKeyAlgorithmValid {
		return fmt.Errorf("invalid wrapping-key-algorithm: %s (must be rsa:2048, ec:secp256r1, ec:secp384r1, or ec:secp521r1)", wrappingKeyAlgorithm)
	}
	// Validate enum for tdf-type
	tdfTypeValid := false
	for _, validValue := range []string{"ztdf", "tdf3", "nano"} {
		if tdfType == validValue {
			tdfTypeValid = true
			break
		}
	}
	if !tdfTypeValid {
		return fmt.Errorf("invalid tdf-type: %s (must be ztdf, tdf3, or nano)", tdfType)
	}

	// Create request
	req := &EncryptRequest{
		Flags: EncryptRequestFlags{
			Out: out,
			Attr: attr,
			WrappingKeyAlgorithm: wrappingKeyAlgorithm,
			MimeType: mimeType,
			TdfType: tdfType,
			EcdsaBinding: ecdsaBinding,
			KasUrlPath: kasUrlPath,
			TargetMode: targetMode,
			WithAssertions: withAssertions,
		},
	}

	// Call handler
	return handler(cmd, req)
}
